<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title></title>
<meta name="Generator" content="Cocoa HTML Writer">
<meta name="CocoaVersion" content="1187.4">
<style type="text/css">
p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; color: #0000ee}
p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; min-height: 12.0px}
p.p5 {margin: 0.0px 0.0px 0.0px 27.0px; text-indent: -27.0px; font: 12.0px Helvetica}
p.p6 {margin: 0.0px 0.0px 0.0px 27.0px; text-indent: -27.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p7 {margin: 0.0px 0.0px 0.0px 27.0px; text-indent: -27.0px; font: 12.0px Helvetica; color: #0000ee}
p.p8 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Helvetica}
p.p9 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 9.0px Monaco; min-height: 12.0px}
p.p10 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 12.0px Helvetica}
p.p11 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p12 {margin: 0.0px 0.0px 0.0px 85.0px; text-indent: -85.0px; font: 12.0px Helvetica}
p.p13 {margin: 0.0px 0.0px 0.0px 85.0px; text-indent: -85.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p14 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 14.0px Helvetica}
p.p15 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Monaco; min-height: 16.0px}
p.p16 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco}
p.p17 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #cd1c00}
p.p18 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Helvetica; min-height: 17.0px}
p.p19 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 14.0px Helvetica; min-height: 17.0px}
p.p20 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #0326cb}
p.p21 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #cd1c00; min-height: 12.0px}
p.p22 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 9.0px Monaco; color: #cd1c00}
p.p23 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 9.0px Monaco}
p.p24 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 9.0px Monaco; color: #0326cb}
p.p25 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 9.0px Monaco; color: #cd1c00; min-height: 12.0px}
span.s1 {font: 18.0px Helvetica}
span.s2 {color: #000000}
span.s3 {text-decoration: underline}
span.s4 {text-decoration: underline ; color: #042eee}
span.s5 {color: #00bbff}
span.s6 {color: #0326cb}
span.s7 {color: #0433ff}
span.s8 {color: #434ccb}
span.s9 {color: #737373}
span.Apple-tab-span {white-space:pre}
</style>
</head>
<body>
<p class="p1"><span class="s1"><b>ZeroXBufRd<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></b></span><b>reads consecutive sequences of segments between zero crossings from one or more buffers with demand-rate control</b></p>
<p class="p2"><br></p>
<p class="p3"><span class="s2"><b>Part of:</b> <a href="../miSCellaneous.html"><span class="s3">miSCellaneous</span></a></span></p>
<p class="p2"><br></p>
<p class="p1"><b>Inherits from: UGen</b></p>
<p class="p4"><br></p>
<p class="p1">ZeroXBufRd is for consecutive reading of segments between zero crossings (half wavesets) from one or more buffers, whereby several reading and processing parameters can be sequenced with demand rate ugens. Full waveset sequences can so be generated as a special case. It needs analysis data prepared with <a href="../ZeroXBufWr.html"><span class="s4">ZeroXBufWr</span></a>. For triggering possibly overlapped (half) wavesets see <a href="../TZeroXBufRd.html"><span class="s4">TZeroXBufRd</span></a>. ZeroXBufRd / TZeroXBufRd can be used for a number of synthesis / processing techniques in a field between wavesets [1, 4, 5], pulsar synthesis [1, 3], buffer modulation and rectification (which are both a kind of waveshaping) and stochastic concatenation methods [2, 6]. There are already existing SC waveset implementations like Alberto de Campo's Wavesets quark (<a href="https://github.com/supercollider-quarks/quarks"><span class="s4">https://github.com/supercollider-quarks/quarks</span></a>) and Olaf Hochherz's SPList (<a href="https://github.com/olafklingt/SPList"><span class="s4">https://github.com/olafklingt/SPList</span></a>), which do language-side analysis and Fabian Seidl's RTWaveSets plugin (<a href="https://github.com/tai-studio/RTWaveSets"><span class="s4">https://github.com/tai-studio/RTWaveSets</span></a>). My focus has been server-side analysis and demand rate ugen control of half waveset parameters as well as multichannel and buffer switch options. Realtime control while analysis is possible, as long as reading is only refering to already analysed sections, but clearly most flexibility is given with a fully analysed buffer, which can also be done in quasi realtime.</p>
<p class="p2"><br></p>
<p class="p1"><b>NOTE: </b>Depending on the multichannel sizes and the options used (rate and dir sequencing) it might be necessary to increase server resources, i.e. the number of interconnect buffers and / or memory size (e.g. s.options.numWireBufs = 256; s.options.memSize = 8192 * 32; s.reboot). Because of overlappings this is more relevant with TZeroXBufRd than with ZeroXBufRd.</p>
<p class="p2"><br></p>
<p class="p1"><b>NOTE: </b>Often it pays to adjust zero crossings in the sound buffer effectively to 0, that way sawtooth-like interpolation artefacts can be avoided. See Ex. 7 below.</p>
<p class="p2"><br></p>
<p class="p1"><b>NOTE: </b>The reading of consecutive half wavesets is implemented with Sweep and retriggering. For that reason each played back half waveset has a minimum length of 2 samples. In the case of adjusted zero crossings that immediately follow each other this can lead to flat sections of a few samples length. Normally this is irrelevant, but you might check setting ZeroXBufWr's adjustZeroXs flag to 2, see the example there and below.</p>
<p class="p2"><br></p>
<p class="p1"><b>NOTE: </b>Demand rate UGens in ZeroXBufRd / TZeroXBufRd must always use inf as repeats arg, this is of course not necessary for nested ones. You might pass a length arg though (Ex. 5).</p>
<p class="p2"><br></p>
<p class="p1"><b>NOTE: </b>For avoiding too long half wavesets it might be useful to apply LeakDC resp. a high pass filter before analysis.</p>
<p class="p2"><br></p>
<p class="p1"><b>NOTE: </b>In rare cases I noticed corrupted buffers in multi buffer examples for no obvious reason.</p>
<p class="p2"><br></p>
<p class="p1"><b>NOTE: </b>For full functionality at least SC 3.7 is recommended (rate sequencing doesn't work in 3.6)</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p1"><b>CREDITS: </b>Thanks to Tommaso Settimi for an inspiring discussion, which gave me a nudge to tackle these classes.<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p1"><b>REFERENCES:</b></p>
<p class="p2"><br></p>
<p class="p5">[1]<span class="Apple-tab-span">	</span>de Campo, Alberto. "Microsound" In: Wilson, S., Cottle, D. and Collins, N. (eds). 2011.<span class="Apple-converted-space"> </span></p>
<p class="p5"><span class="Apple-tab-span">	</span><i>The SuperCollider Book</i>. Cambridge, MA: MIT Press, 463-504.</p>
<p class="p6"><span class="Apple-tab-span">	</span></p>
<p class="p5">[2]<span class="Apple-tab-span">	</span>Luque, Sergio (2006). <i>Stochastic Synthesis, Origins and Extensions</i>. Institute of Sonology, Royal Conservatory, The Netherlands.<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="s2"><span class="Apple-tab-span">	</span><a href="http://sergioluque.com/"><span class="s3">http://sergioluque.com</span></a></span></p>
<p class="p6"><br></p>
<p class="p5">[3]<span class="Apple-tab-span">	</span>Roads, Curtis (2001). <i>Microsound</i>. Cambridge, MA: MIT Press.</p>
<p class="p6"><span class="Apple-tab-span">	</span></p>
<p class="p5">[4]<span class="Apple-tab-span">	</span>Seidl, Fabian (2016). <i>Granularsynthese mit Wavesets für Live-Anwendungen</i>. Master Thesis, TU Berlin.</p>
<p class="p7"><span class="s2"><span class="Apple-tab-span">	</span><a href="https://www2.ak.tu-berlin.de/~akgroup/ak_pub/abschlussarbeiten/2016/Seidl_MasA.pdf"><span class="s3">https://www2.ak.tu-berlin.de/~akgroup/ak_pub/abschlussarbeiten/2016/Seidl_MasA.pdf</span></a></span></p>
<p class="p6"><br></p>
<p class="p5">[5]<span class="Apple-tab-span">	</span>Wishart, Trevor (1994). <i>Audible Design</i>. York: Orpheus The Pantomime Ltd.<span class="Apple-converted-space"> </span></p>
<p class="p6"><br></p>
<p class="p5">[6]<span class="Apple-tab-span">	</span>Xenakis, Iannis (1992). <i>Formalized Music</i>. Hillsdale, NY: Pendragon Press, 2nd Revised edition.</p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p2"><br></p>
<p class="p3"><span class="s2"><b>See also: </b><a href="../TZeroXBufRd.html"><span class="s3">TZeroXBufRd</span></a>,<b> </b><a href="../ZeroXBufWr.html"><span class="s3">ZeroXBufWr</span></a>,<b> </b><a href="../DX suite.html"><span class="s3">DX suite</span></a>,<b> </b><a href="../DXMix.html"><span class="s3">DXMix</span></a>, <a href="../DXMixIn.html"><span class="s3">DXMixIn</span></a>, <a href="../DXEnvFan.html"><span class="s3">DXEnvFan</span></a>,<b> </b><a href="../DXEnvFanOut.html"><span class="s3">DXEnvFanOut</span></a>, <a href="../DXFanOut.html"><span class="s3">DXFanOut</span></a>, <a href="../Buffer Granulation.html"><span class="s3">Buffer Granulation</span></a>, <a href="../Live Granulation.html"><span class="s3">Live Granulation</span></a>, <a href="../PbindFx.html"><span class="s3">PbindFx</span></a></span><span class="s5">,</span><span class="s2"> <a href="../kitchen studies.html"><span class="s3">kitchen studies</span></a></span></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p8"><b>Creation / Class Methods</b></p>
<p class="p9"><br></p>
<p class="p10"><b><span class="Apple-tab-span">	</span>*ar (sndBuf, zeroXBuf, bufMix, zeroX = 0, power = 1, mul = 1, add = 0, rate = 1, rateMul = 1, dir = 1, interpl = 4, dUniqueBufSize = 1048576,</b></p>
<p class="p10"><b><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>length = inf, maxTime = inf, att = 0, rel = 0, curve = -4, doneAction = 0)</b></p>
<p class="p11"><b><span class="Apple-tab-span">	</span></b></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>sndBuf </b>- Buffer or SequenceableCollection of Buffers to read the data from, data must correspond to <b>zeroXBuf</b>.</p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>zeroXBuf </b>- Analysis Buffer resp. SequenceableCollection of such, prepared with <a href="../ZeroXBufWr.html"><span class="s4">ZeroXBufWr</span></a>.<span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Must refer to data passed to <b>sndBuf</b>.</p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>bufMix </b>- A Number indicating the <b>sndBuf</b> index, a demand rate or other ugens returning <b>sndBuf</b> indices or<span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>a SequenceableCollection of such. In contrast to other args combinations of demand rate and normal ugens are not valid.<span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If <b>bufMix </b>equals<b> </b>nil (default) the size of the returned signal equals the size of <b>sndBuf</b>,</p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>otherwise it equals its own size.</p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>zeroX </b>- A Number indicating the index in <b>zeroXBuf</b>, a demand rate or other ugens returning <b>zeroXBuf</b> indices or<span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>a SequenceableCollection of such.</p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If in this case the overall multichannel size determined by <b>sndBuf </b>or<b> bufMix </b>is larger than the size of <b>zeroX</b></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>and the latter contains demand rate ugens, they must all be wrapped into Functions for being used more than once.</p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 0.</p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>power </b>- Used for processing the buffer signal according to the formula: sig ** <b>power</b> * <b>mul</b> + <b>add</b> per half waveset.<span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Must be a positive Number, a demand rate or other ugens returning <b>power </b>values or<span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>a SequenceableCollection of such.</p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If in this case the overall multichannel size determined by <b>sndBuf </b>or<b> bufMix </b>is larger than the size of <b>power</b></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>and the latter contains demand rate ugens, they must all be wrapped into Functions for being used more than once.</p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 1.</p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>mul </b>- Used for processing the buffer signal according to the formula: sig ** <b>power</b> * <b>mul</b> + <b>add</b> per half waveset.<span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Must be a Number, a demand rate or other ugens returning <b>mul </b>values or<span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>a SequenceableCollection of such.</p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If in this case the overall multichannel size determined by <b>sndBuf </b>or<b> bufMix </b>is larger than the size of <b>mul</b></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>and the latter contains demand rate ugens, they must all be wrapped into Functions for being used more than once.</p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 1.<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>add </b>- Used for processing the buffer signal according to the formula: sig ** <b>power</b> * <b>mul</b> + <b>add</b> per half waveset.<span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Must be a Number, a demand rate or other ugens returning <b>add </b>values or<span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>a SequenceableCollection of such.</p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If in this case the overall multichannel size determined by <b>sndBuf </b>or<b> bufMix </b>is larger than the size of <b>add</b></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>and the latter contains demand rate ugens, they must all be wrapped into Functions for being used more than once.</p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 0.<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>rate </b>- Determines the playback rate per half waveset together with <b>rateMul</b>.<span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Must be a positive Number, a demand rate or other ugens returning <b>rate </b>values or a SequenceableCollection of such.<span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If in this case the overall multichannel size determined by <b>sndBuf </b>or<b> bufMix </b>is larger than the size of <b>rate</b></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>and the latter contains demand rate ugens, they must all be wrapped into Functions for being used more than once.</p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>In contrast to other args combinations of demand rate and normal ugens are not valid for implementational reasons.<span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Though you can pass a demand rate ugen here and a normal ugen to <b>rateMul </b>(or vice versa) which are then multiplied per half waveset<b>.</b></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 1.<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>rateMul </b>- Determines the playback rate per half waveset together with <b>rate</b>.<span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Must be a positive Number, a demand rate or other ugens returning <b>rateMul </b>values or a SequenceableCollection of such.<span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If in this case the overall multichannel size determined by <b>sndBuf </b>or<b> bufMix </b>is larger than the size of <b>rateMul</b></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>and the latter contains demand rate ugens, they must all be wrapped into Functions for being used more than once.</p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>In contrast to other args combinations of demand rate and normal ugens are not valid for implementational reasons.<span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Though you can pass a normal ugen here and a demand rate ugen to <b>rate </b>(or vice versa) which are then multiplied per half waveset<b>.</b></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 1.<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>dir </b>- Determines the playback direction of half wavesets.<span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Must be +1 or -1, a demand rate or other ugens returning <b>dir </b>values or<span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>a SequenceableCollection of such.<span class="Apple-converted-space">  </span>If in this case the overall multichannel size determined by <b>sndBuf </b>or<b> bufMix </b>is<span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>larger than the size of <b>dir</b> and the latter contains demand rate ugens, they must all be wrapped into Functions for<span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>being used more than once. In contrast to other args combinations of demand rate and normal ugens are not valid.</p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 1.<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>interpl </b>- Determines the interpolation type for the BufRd ugens.<span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Must equal 1 (no), 2 (linear) or 4 (cubic) or a SequenceableCollection of these numbers.</p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 4.<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>dUniqueBufSize </b>- Determines the buffer size for Dunique objects which have to be used in the case</p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>of demand rate ugens passed to <b>rate</b>, <b>dir</b> or <b>bufMix</b>. See Ex.2.</p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Must be an Integer or a SequenceableCollection of Integers.</p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 1048576.<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>length </b>- Determines the number of triggers before release of the overall asr envelope.<span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Can be a Sequenceable Collection too. Overruled by <b>maxTime</b> if this is reached before.</p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to inf.<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>maxTime </b>- Determines the time before release of the overall asr envelope.<span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Can be a Sequenceable Collection too. Overruled by <b>length</b> if this is reached before.</p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to inf.<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>att </b>- Attack time of overall asr envelope or SequenceableCollection thereof.<span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 0.<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>rel </b>- Release time of overall asr envelope or SequenceableCollection thereof. <span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 0.<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>curve </b>- Curve of overall asr envelope or SequenceableCollection thereof. <span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to -4.<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>doneAction </b>- Done action of overall asr envelope or SequenceableCollection thereof. <span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 0.<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p11"><b><span class="Apple-tab-span">	</span></b></p>
<p class="p11"><br></p>
<p class="p14"><b>Examples</b></p>
<p class="p15"><br></p>
<p class="p16">(</p>
<p class="p17">// boot with extended resources, might be needed for some examples</p>
<p class="p16">s = <span class="s6">Server</span>.local;</p>
<p class="p16"><span class="s6">Server</span>.default = s;</p>
<p class="p16">s.options.numWireBufs = 256;<span class="Apple-converted-space"> </span></p>
<p class="p16">s.options.memSize = 8192 * 32;<span class="Apple-converted-space"> </span></p>
<p class="p16">s.reboot;</p>
<p class="p16">)</p>
<p class="p18"><br></p>
<p class="p19"><br></p>
<p class="p14"><b>Ex.1) Basic usage</b></p>
<p class="p11"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p17">// prepare two short buffers for audio and zero crossing data</p>
<p class="p17">// the size of needed zeroX data space can be roughly estimated</p>
<p class="p4"><br></p>
<p class="p16">(</p>
<p class="p16">b = <span class="s6">Buffer</span>.alloc(s, 2000);</p>
<p class="p16">z = <span class="s6">Buffer</span>.alloc(s, 200);</p>
<p class="p16">)</p>
<p class="p4"><br></p>
<p class="p17">// analyse a short snippet of ring modulation</p>
<p class="p4"><br></p>
<p class="p16">(</p>
<p class="p16">{</p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="s7">var</span> src = <span class="s6">SinOsc</span>.ar(300) * <span class="s6">SinOsc</span>.ar(120) + <span class="s6">SinOsc</span>.ar(30) * 0.1;</p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="s6">ZeroXBufWr</span>.ar(src, b, z, startWithZeroX: 1, doneAction: 2);</p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span></span>Silent<span class="s2">.ar</span></p>
<p class="p16">}.play</p>
<p class="p16">)</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// check the waveform</p>
<p class="p4"><br></p>
<p class="p16">b.plot</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// loop 3rd half waveset</p>
<p class="p17">// compare plot and scope</p>
<p class="p4"><br></p>
<p class="p16">x = { <span class="s6">ZeroXBufRd</span>.ar(b, z, zeroX: 2) }.play</p>
<p class="p4"><br></p>
<p class="p16">s.scope</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// loop a whole waveset</p>
<p class="p17">// demand rate ugens in ZeroXBufRd should always use inf as repeats arg</p>
<p class="p4"><span class="Apple-converted-space"> </span></p>
<p class="p4"><br></p>
<p class="p16">x = { <span class="s6">ZeroXBufRd</span>.ar(b, z, zeroX: <span class="s6">Dseq</span>([1, 2], <span class="s8">inf</span>)) }.play</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// Note that the distance between zero crossings can be very short,</p>
<p class="p17">// here the half waveset at index 5 (735-740) has a length of only 5 samples and the amplitude is low.</p>
<p class="p4"><br></p>
<p class="p17">// zero crossing indices</p>
<p class="p4"><br></p>
<p class="p16">z.loadToFloatArray(action: { <span class="s7">|b|</span> b.postln })</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// the signal is hardly audible, but there as freqscope shows</p>
<p class="p4"><br></p>
<p class="p16">x = { <span class="s6">ZeroXBufRd</span>.ar(b, z, zeroX: 5) }.play</p>
<p class="p4"><br></p>
<p class="p16">s.freqscope</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// loop a group of 3 wavesets</p>
<p class="p4"><br></p>
<p class="p16">x = { <span class="s6">ZeroXBufRd</span>.ar(b, z, zeroX: <span class="s6">Dseq</span>((1..6), <span class="s8">inf</span>)) }.play</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// sequence multiplier for half wavesets</p>
<p class="p4"><br></p>
<p class="p16">x = { <span class="s6">ZeroXBufRd</span>.ar(b, z, zeroX: <span class="s6">Dseq</span>([1, 2], <span class="s8">inf</span>), mul: <span class="s6">Dseq</span>([1, 0.2], <span class="s8">inf</span>)) }.play</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// mul can be used for rectifying effects</p>
<p class="p4"><br></p>
<p class="p16">x = { <span class="s6">ZeroXBufRd</span>.ar(b, z, zeroX: <span class="s6">Dseq</span>((1..2), <span class="s8">inf</span>), mul: <span class="s6">Dseq</span>([0, 1, 1], <span class="s8">inf</span>)) }.play</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// add an offset sequence, this results in a pulse-like effect</p>
<p class="p4"><br></p>
<p class="p16">x = { <span class="s6">ZeroXBufRd</span>.ar(b, z, zeroX: <span class="s6">Dseq</span>([1, 2], <span class="s8">inf</span>), add: <span class="s6">Dseq</span>([-0.05, 0.05], <span class="s8">inf</span>)) * 0.5 }.play</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p16">x = { <span class="s6">ZeroXBufRd</span>.ar(b, z, zeroX: <span class="s6">Dseq</span>([1, 2], <span class="s8">inf</span>), add: <span class="s6">Dseq</span>([0.05, -0.05], <span class="s8">inf</span>)) * 0.5 }.play</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// half wavesets can also get a power,</p>
<p class="p17">// per waveset the signal is calculated according to</p>
<p class="p17">// ((sig ** power) * mul) + add</p>
<p class="p21"><br></p>
<p class="p17">// be careful with this arg moving away from 1 !<span class="Apple-converted-space"> </span></p>
<p class="p17">// high power values can result in loud signals if the source has values outside [-1, 1] and</p>
<p class="p17">// small power values can also become loud with source values near zero</p>
<p class="p21"><br></p>
<p class="p4"><br></p>
<p class="p16">x = { <span class="s6">ZeroXBufRd</span>.ar(b, z, zeroX: <span class="s6">Dseq</span>([1, 2], <span class="s8">inf</span>), power: 0.7) }.play</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p16">x = { <span class="s6">ZeroXBufRd</span>.ar(b, z, zeroX: <span class="s6">Dseq</span>([1, 2], <span class="s8">inf</span>), power: <span class="s6">Dseq</span>([0.8, 1.7, 1], <span class="s8">inf</span>)) }.play</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p21"><br></p>
<p class="p14"><b>Ex.2) The 'rate' and 'dir' args</b></p>
<p class="p19"><br></p>
<p class="p17">// needs Buffers from Ex.1</p>
<p class="p4"><br></p>
<p class="p16">s.scope</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// playback rates can be defined generally ...</p>
<p class="p4"><br></p>
<p class="p16">x = { <span class="s6">ZeroXBufRd</span>.ar(b, z, zeroX: <span class="s6">Dseq</span>([1, 2], <span class="s8">inf</span>), rate: 2.5) }.play</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// ... or as sequence</p>
<p class="p4"><br></p>
<p class="p16">x = { <span class="s6">ZeroXBufRd</span>.ar(b, z, zeroX: <span class="s6">Dseq</span>([1, 2], <span class="s8">inf</span>), rate: <span class="s6">Dseq</span>((1..3), <span class="s8">inf</span>)) }.play</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// slightly different: here the whole waveset gets one rate</p>
<p class="p4"><br></p>
<p class="p16">x = { <span class="s6">ZeroXBufRd</span>.ar(b, z, zeroX: <span class="s6">Dseq</span>([1, 2], <span class="s8">inf</span>), rate: <span class="s6">Dstutter</span>(2, <span class="s6">Dseq</span>((1..3), <span class="s8">inf</span>))) }.play</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// with the dir argument set to -1 the half wave set is reversed</p>
<p class="p4"><br></p>
<p class="p16">x = { <span class="s6">ZeroXBufRd</span>.ar(b, z, zeroX: 7) }.play</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// compare scope, no audible difference here</p>
<p class="p4"><br></p>
<p class="p16">x = { <span class="s6">ZeroXBufRd</span>.ar(b, z, zeroX: 7, dir: -1) }.play</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// dir can also be sequenced</p>
<p class="p4"><br></p>
<p class="p16">x = { <span class="s6">ZeroXBufRd</span>.ar(b, z, zeroX: 7, dir: <span class="s6">Dseq</span>([1, 1, -1], <span class="s8">inf</span>)) }.play</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p21"><br></p>
<p class="p21"><br></p>
<p class="p17">// When demand rate ugens are used for 'rate' or 'dir' args ZeroXBufRd employs Dunique objects.</p>
<p class="p17">// This means that Buffers have to be allocated for counting, and if the Buffer is full</p>
<p class="p17">// the synthesis fails. By default a value of 1048576 is defined for 'dUniqueBufSize'.</p>
<p class="p17">// This should be sufficient for at least some minutes auf audio in average use cases.</p>
<p class="p4"><br></p>
<p class="p17">// However with very fast triggering you might want to pass a higher value.</p>
<p class="p17">// With multichannel applications it might be necessary then to run the server with higher memSize.</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// With a deliberately bad (low) size, sequencing fails after a second</p>
<p class="p4"><br></p>
<p class="p16">x = { <span class="s6">ZeroXBufRd</span>.ar(b, z, zeroX: 1, rate: <span class="s6">Dseq</span>([1, 2], <span class="s8">inf</span>), dUniqueBufSize: 1024) }.play</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p17">// From low values you can roughly estimate the needed dUniqueBufSize to safely run your application</p>
<p class="p17">// for a given time</p>
<p class="p21"><br></p>
<p class="p4"><br></p>
<p class="p19"><br></p>
<p class="p19"><br></p>
<p class="p14"><b>Ex.3) Passing ordinary UGens as args</b></p>
<p class="p4"><br></p>
<p class="p21"><br></p>
<p class="p17">// needs Buffers from Ex.1</p>
<p class="p21"><br></p>
<p class="p17">// values are sampled and hold for the duration of the segments</p>
<p class="p4"><br></p>
<p class="p16">s.scope</p>
<p class="p4"><br></p>
<p class="p16">x = { <span class="s6">ZeroXBufRd</span>.ar(b, z, zeroX: <span class="s6">SinOsc</span>.ar(<span class="s6">SinOsc</span>.ar(0.1).range(0.2, 5)).range(1, 15)) }.play</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// more fun with moving rates</p>
<p class="p4"><br></p>
<p class="p16">(</p>
<p class="p16">x = {<span class="Apple-converted-space"> </span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span></span>ZeroXBufRd<span class="s2">.ar(</span></p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>b, z,<span class="Apple-converted-space"> </span></p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>zeroX: <span class="s6">LFDNoise3</span>.ar(<span class="s6">SinOsc</span>.ar(0.1).range(1, 10)).range(1, 15),</p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>rate: <span class="s6">SinOsc</span>.ar(<span class="s6">SinOsc</span>.ar(0.3).range(0.2, 5)).exprange(1, 5)</p>
<p class="p16"><span class="Apple-tab-span">	</span>) ! 2</p>
<p class="p16">}.play</p>
<p class="p16">)</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// warp effect with accelerating rates</p>
<p class="p4"><br></p>
<p class="p16">(</p>
<p class="p16">x = {<span class="Apple-converted-space"> </span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span></span>ZeroXBufRd<span class="s2">.ar(</span></p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>b, z,<span class="Apple-converted-space"> </span></p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>zeroX: <span class="s6">LFDNoise3</span>.ar(<span class="s6">SinOsc</span>.ar(0.1).range(1, 10)).range(1, 15),</p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>rate: <span class="s6">Dseq</span>((1..50) / 20 + 0.5, <span class="s8">inf</span>)</p>
<p class="p16"><span class="Apple-tab-span">	</span>) ! 2</p>
<p class="p16">}.play</p>
<p class="p16">)</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// also combinations of demand rate and ordinary ugens are possible</p>
<p class="p17">// though with the exception of rate, dir and bufMix args</p>
<p class="p4"><br></p>
<p class="p16">(</p>
<p class="p16">x = {<span class="Apple-converted-space"> </span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span></span>ZeroXBufRd<span class="s2">.ar(</span></p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>b, z,<span class="Apple-converted-space"> </span></p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>zeroX: <span class="s6">LFDNoise3</span>.ar(<span class="s6">SinOsc</span>.ar(0.1).range(1, 10)).range(1, 15),</p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>rate: <span class="s6">Dstutter</span>(<span class="s6">Dwhite</span>(10, 100), <span class="s6">Dwhite</span>(0.5, 2)),</p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>mul: <span class="s6">Dseq</span>([0.2, 0.2, 1], <span class="s8">inf</span>) * <span class="s6">LFDNoise3</span>.ar(5).range(1, 5)</p>
<p class="p16"><span class="Apple-tab-span">	</span>) ! 2</p>
<p class="p16">}.play</p>
<p class="p16">)</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// for combinations of normal and demand ugens with the rate arg rateMul can be used</p>
<p class="p4"><br></p>
<p class="p16">(</p>
<p class="p16">x = {<span class="Apple-converted-space"> </span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span></span>ZeroXBufRd<span class="s2">.ar(</span></p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>b, z,<span class="Apple-converted-space"> </span></p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>zeroX: <span class="s6">LFDNoise3</span>.ar(<span class="s6">SinOsc</span>.ar(0.1).range(1, 10)).range(1, 15),</p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>rate: <span class="s6">Dstutter</span>(<span class="s6">Dstutter</span>(3, <span class="s6">Dwhite</span>(1, 5)), <span class="s6">Dseq</span>([0.5, 1, 1.5], <span class="s8">inf</span>)),</p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>rateMul: <span class="s6">LFDNoise3</span>.ar(5).range(1, 5)</p>
<p class="p16"><span class="Apple-tab-span">	</span>) ! 2</p>
<p class="p16">}.play</p>
<p class="p16">)</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// free resources</p>
<p class="p4"><br></p>
<p class="p16">(</p>
<p class="p16">b.free;</p>
<p class="p16">z.free;</p>
<p class="p16">)</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p14"><b>Ex.4) Multichannel usage and the 'bufMix' arg</b></p>
<p class="p19"><br></p>
<p class="p17">// Without passing a bufMix arg the size of the returned signal is determined by the buffer input.<span class="Apple-converted-space"> </span></p>
<p class="p17">// It may be a single channel buffer or an array of single channel buffers,<span class="Apple-converted-space"> </span></p>
<p class="p17">// in correspondence with the analysis buffer(s) - multichannel buffers are not allowed.<span class="Apple-converted-space"> </span></p>
<p class="p17">// If bufMix is passed, it determines the size of the returned signal,<span class="Apple-converted-space"> </span></p>
<p class="p17">// its components can be demand rate or other ugens to control switching between buffers per half waveset.</p>
<p class="p21"><br></p>
<p class="p17">// Note: buffer switching can become CPU-demanding with a lot of Buffers<span class="Apple-converted-space"> </span></p>
<p class="p17">// as for fast switching it is necessary to play all in parallel</p>
<p class="p4"><br></p>
<p class="p16">(</p>
<p class="p17">// boot with extended resources</p>
<p class="p16">s = <span class="s6">Server</span>.local;</p>
<p class="p16"><span class="s6">Server</span>.default = s;</p>
<p class="p16">s.options.numWireBufs = 256;<span class="Apple-converted-space"> </span></p>
<p class="p16">s.options.memSize = 8192 * 32;<span class="Apple-converted-space"> </span></p>
<p class="p16">s.reboot;</p>
<p class="p16">)</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// prepare 3 buffers</p>
<p class="p4"><br></p>
<p class="p16">(</p>
<p class="p16">b = { <span class="s6">Buffer</span>.alloc(s, 1000, 1) } ! 3;</p>
<p class="p16">z = { <span class="s6">Buffer</span>.alloc(s, 100, 1) } ! 3;</p>
<p class="p16">)</p>
<p class="p4"><br></p>
<p class="p17">// fill with basic waveforms</p>
<p class="p16">(</p>
<p class="p16">{</p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="s7">var</span> src = [</p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">SinOsc</span>.ar(400),</p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">LFTri</span>.ar(400),</p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">SinOsc</span>.ar(400) ** 10</p>
<p class="p16"><span class="Apple-tab-span">	</span>];</p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="s6">ZeroXBufWr</span>.ar(src, b, z, startWithZeroX: 1, doneAction: 2);</p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span></span>Silent<span class="s2">.ar</span></p>
<p class="p16">}.play</p>
<p class="p16">)</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p16">s.scope(3)</p>
<p class="p4"><br></p>
<p class="p17">// play 3 channels</p>
<p class="p4"><br></p>
<p class="p16">x = { <span class="s6">ZeroXBufRd</span>.ar(b, z, zeroX: 1) * 0.1 }.play</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// play from 1st buffer</p>
<p class="p4"><br></p>
<p class="p16">x = { <span class="s6">ZeroXBufRd</span>.ar(b, z, bufMix: 0, zeroX: <span class="s6">Dseq</span>([0, 1], <span class="s8">inf</span>)) * 0.2 }.play</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// play from 3rd and 1st buffer</p>
<p class="p17">// to use equally defined demand rate ugens for both, wrap them into a Function</p>
<p class="p4"><br></p>
<p class="p16">x = { <span class="s6">ZeroXBufRd</span>.ar(b, z, bufMix: [2, 0], zeroX: { <span class="s6">Dseq</span>([0, 1], <span class="s8">inf</span>) }) * 0.1 }.play</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// play 2 channels with different zeroX sequences</p>
<p class="p4"><br></p>
<p class="p16">(</p>
<p class="p16">x = {</p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span></span>ZeroXBufRd<span class="s2">.ar(</span></p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>b, z,</p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>bufMix: [1, 2],</p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>zeroX: [<span class="s6">Dseq</span>([0, 0, 1], <span class="s8">inf</span>), <span class="s6">Dseq</span>([0, 1], <span class="s8">inf</span>)]</p>
<p class="p16"><span class="Apple-tab-span">	</span>) * 0.1</p>
<p class="p16">}.play</p>
<p class="p16">)</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// buffers can be switched per half waveset</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p16">x = { <span class="s6">ZeroXBufRd</span>.ar(b, z, bufMix: <span class="s6">Dseq</span>([0, 1, 2], <span class="s8">inf</span>), zeroX: 2, mul: 0.3) }.play</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p16">x = { <span class="s6">ZeroXBufRd</span>.ar(b, z, bufMix: <span class="s6">Dseq</span>([0, 1], <span class="s8">inf</span>), zeroX: <span class="s6">Dseq</span>([1, 2], <span class="s8">inf</span>), mul: 0.3) }.play</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// Gendy-like texture</p>
<p class="p4"><br></p>
<p class="p16">(</p>
<p class="p16">x = {</p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span></span>ZeroXBufRd<span class="s2">.ar(</span></p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>b, z,</p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>bufMix: { <span class="s6">Dseq</span>([0, 1, 2], <span class="s8">inf</span>) } ! 2,</p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>zeroX: 2,</p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>mul: 0.1,</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// array of Drands with different offset</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// the average of the Drand output is 50,</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// so on average 1/4 is added to x</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// and the harmonic relation of L:R is 5:7 -&gt; tritone</p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>rate: [1, 1.5].collect { <span class="s7">|x|</span> <span class="s6">Drand</span>((1..100) / 200 + x, <span class="s8">inf</span>) }</p>
<p class="p16"><span class="Apple-tab-span">	</span>)</p>
<p class="p16">}.play</p>
<p class="p16">)</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// bufMix determines size</p>
<p class="p17">// other args are expanded accordingly</p>
<p class="p4"><br></p>
<p class="p16">(</p>
<p class="p16">x = {</p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="s6">ZeroXBufRd</span>.ar(b, z,</p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>bufMix: { <span class="s6">Dseq</span>([0, 1, 2], <span class="s8">inf</span>) } ! 2,</p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>zeroX: { <span class="s6">Dseq</span>([1, 2], <span class="s8">inf</span>) },</p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>mul: { <span class="s6">Dstutter</span>(<span class="s6">Diwhite</span>(1, 1000), <span class="s6">Drand</span>([0.01, 0.07, 0.2], <span class="s8">inf</span>)) },</p>
<p class="p16"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>rate: { <span class="s6">Dstutter</span>(<span class="s6">Diwhite</span>(1, 12), <span class="s6">Dwhite</span>(0.1, 10)) }</p>
<p class="p16"><span class="Apple-tab-span">	</span>)</p>
<p class="p16">}.play</p>
<p class="p16">)</p>
<p class="p4"><br></p>
<p class="p16">x.release</p>
<p class="p4"><br></p>
<p class="p18"><br></p>
<p class="p9"><br></p>
<p class="p14"><b>Ex.5) The overall envelope</b></p>
<p class="p19"><br></p>
<p class="p17">// The finishing of a ZeroXBufRd is not detemined by finite demand rate ugens but by an overall envelope,<span class="Apple-converted-space"> </span></p>
<p class="p17">// its release section is triggered by a maximum number of half wavesets ('length') or a maximum time.<span class="Apple-converted-space"> </span></p>
<p class="p4"><br></p>
<p class="p17">// Buffers from Ex.4</p>
<p class="p4"><br></p>
<p class="p16">{ <span class="s6">ZeroXBufRd</span>.ar(b[0], z[0], rate: 1, length: 10, rel: 0.01) }.plot(0.03)</p>
<p class="p4"><br></p>
<p class="p16">{ <span class="s6">ZeroXBufRd</span>.ar(b[0], z[0], rate: 1, maxTime: 0.01, rel: 0.01) }.plot(0.03)</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// envelopes can be differentiated</p>
<p class="p4"><br></p>
<p class="p16">{ <span class="s6">ZeroXBufRd</span>.ar(b[0..1], z[0..1], rate: 1, maxTime: [0.01, 0.005], rel: [0.005, 0.02]) }.plot(0.03)</p>
<p class="p4"><br></p>
<p class="p16">{ <span class="s6">ZeroXBufRd</span>.ar(b[0..1], z[0..1], rate: 1, length: [7, 2], rel: [0.005, 0.02]) }.plot(0.03)</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p17">// there should be only one doneAction 2 in this case</p>
<p class="p4"><br></p>
<p class="p16">{ <span class="s6">ZeroXBufRd</span>.ar(b[0..1], z[0..1], rate: 1, maxTime: [0.01, 0.005], rel: [0.05, 0.5], doneAction: [0, 2]) }.play</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p16">(</p>
<p class="p16">b.do(<span class="s6">_</span>.free);</p>
<p class="p16">z.do(<span class="s6">_</span>.free);</p>
<p class="p16">)</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p14"><b>Ex.6) Simultaneous writing and reading</b></p>
<p class="p9"><br></p>
<p class="p9"><br></p>
<p class="p22">// The reading of half wavesets can start before analysis is finished,</p>
<p class="p22">// if ZeroXBufRd is carefully used in with<span class="s2"> </span>a bit of delay.</p>
<p class="p9"><br></p>
<p class="p9"><br></p>
<p class="p22">// prepare buffers</p>
<p class="p9"><br></p>
<p class="p23">(</p>
<p class="p23">p = <span class="s6">Platform</span>.resourceDir +/+ <span class="s9">"sounds/a11wlk01.wav"</span>;</p>
<p class="p23">b = <span class="s6">Buffer</span>.read(s, p);</p>
<p class="p23">)</p>
<p class="p9"><br></p>
<p class="p23">(</p>
<p class="p23">z = <span class="s6">Buffer</span>.alloc(s, b.duration * 44100 / 5, 1);</p>
<p class="p23">s.scope;</p>
<p class="p23">)</p>
<p class="p9"><br></p>
<p class="p9"><br></p>
<p class="p9"><br></p>
<p class="p22">// Here the average playback rate equals 1 (0.8 = 4/5, 1.25 = 5/4),</p>
<p class="p22">// so playback will not be faster than writing.</p>
<p class="p9"><br></p>
<p class="p23">(</p>
<p class="p23">{</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="s7">var</span> src = <span class="s6">PlayBuf</span>.ar(1, b, <span class="s6">BufRateScale</span>.ir(b));</p>
<p class="p22"><span class="s2"><span class="Apple-tab-span">	</span></span>// write zero crossings, but no need to overwrite sound buffer</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="s6">ZeroXBufWr</span>.ar(src, b, z, startWithZeroX: 1, writeSndBuf: <span class="s8">false</span>);</p>
<p class="p24"><span class="s2"><span class="Apple-tab-span">	</span></span>DelayL<span class="s2">.ar(</span></p>
<p class="p24"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>ZeroXBufRd<span class="s2">.ar(</span></p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>b, z,</p>
<p class="p22"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// Dseries keeps counting through the half-filled zeroX buffer</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>zeroX: <span class="s6">Dseries</span>(),</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>rate: <span class="s6">Dstutter</span>(10, <span class="s6">Dseq</span>([0.8, 1, 1.25], <span class="s8">inf</span>)),</p>
<p class="p22"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// estimate end time</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>maxTime: b.duration + 1,</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>doneAction: 2</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>),</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>0.2,</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>0.1</p>
<p class="p23"><span class="Apple-tab-span">	</span>) ! 2;</p>
<p class="p23">}.play</p>
<p class="p23">)</p>
<p class="p9"><br></p>
<p class="p23">(</p>
<p class="p23">b.free;</p>
<p class="p23">z.free;</p>
<p class="p23">)</p>
<p class="p9"><br></p>
<p class="p22">// The same can be done with a live-generated signal or a mic input,</p>
<p class="p22">// but ensure that reading comes after writing !</p>
<p class="p9"><br></p>
<p class="p9"><br></p>
<p class="p22">// FAILURE BY BAD DEFINITION !</p>
<p class="p22">// rates are fast, so zeroX indices are referred before analysis<span class="Apple-converted-space"> </span></p>
<p class="p22">// resulting in garbage noise</p>
<p class="p9"><br></p>
<p class="p9"><br></p>
<p class="p23">(</p>
<p class="p23">b = { <span class="s6">Buffer</span>.alloc(s, 5 * 44100) } ! 2;</p>
<p class="p23">z = { <span class="s6">Buffer</span>.alloc(s, 2 * 44100) } ! 2;</p>
<p class="p23">)</p>
<p class="p9"><br></p>
<p class="p9"><br></p>
<p class="p23">(</p>
<p class="p23">{</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="s7">var</span> src = <span class="s6">LFDNoise3</span>.ar(300 ! 2), sig;</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="s6">ZeroXBufWr</span>.ar(src, b, z, startWithZeroX: 1);</p>
<p class="p23"><span class="Apple-tab-span">	</span>sig = <span class="s6">DelayL</span>.ar(</p>
<p class="p24"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>ZeroXBufRd<span class="s2">.ar(</span></p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>b, z,</p>
<p class="p22"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// Dseries keeps counting through the half-filled zeroX buffer</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>zeroX: { <span class="s6">Dseries</span>() },</p>
<p class="p9"><br></p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>rate: { <span class="s6">Dseq</span>((1..10) / <span class="s6">LFDNoise3</span>.ar(3).range(5, 10) + 1, <span class="s8">inf</span>) },</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>mul: { <span class="s6">Dstutter</span>(<span class="s6">Dwhite</span>(50, 500), <span class="s6">Drand</span>([0.02, 0.1, 0.5], <span class="s8">inf</span>)) },</p>
<p class="p22"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// estimate end time</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>maxTime: 10,</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>att: 0.2,</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>rel: 5,</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>doneAction: 2</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>),</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>0.2,</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>0.1</p>
<p class="p23"><span class="Apple-tab-span">	</span>);</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="s6">LeakDC</span>.ar(sig)</p>
<p class="p23">}.play</p>
<p class="p23">)</p>
<p class="p9"><br></p>
<p class="p9"><br></p>
<p class="p9"><br></p>
<p class="p22">//<span class="Apple-converted-space">  </span>Reasonable realtime usage</p>
<p class="p22">//<span class="Apple-converted-space">  </span>zeroX is deferred by stuttering, rates are sufficiently low</p>
<p class="p9"><br></p>
<p class="p23">(</p>
<p class="p23">b.do(<span class="s6">_</span>.zero);</p>
<p class="p23">z.do(<span class="s6">_</span>.zero);</p>
<p class="p23">)</p>
<p class="p9"><br></p>
<p class="p9"><br></p>
<p class="p23">(</p>
<p class="p23">{</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="s7">var</span> src = <span class="s6">LFDNoise3</span>.ar(3000 ! 2);</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="s6">ZeroXBufWr</span>.ar(src, b, z, startWithZeroX: 1);</p>
<p class="p24"><span class="s2"><span class="Apple-tab-span">	</span></span>DelayL<span class="s2">.ar(</span></p>
<p class="p24"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>ZeroXBufRd<span class="s2">.ar(<span class="Apple-tab-span">	</span></span></p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>b, z,</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>zeroX: { <span class="s6">Dstutter</span>(<span class="s6">Dwhite</span>(50, 300), <span class="s6">Dseries</span>()) * 2 + <span class="s6">Dseq</span>((1..4), <span class="s8">inf</span>) },</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>rate: { <span class="s6">Dseq</span>((1..5) / <span class="s6">LFDNoise3</span>.ar(3).range(5, 10) + 0.5, <span class="s8">inf</span>) },</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>mul: { <span class="s6">Dstutter</span>(<span class="s6">Dwhite</span>(50, 500), <span class="s6">Drand</span>([0.05, 0.3, 0.7], <span class="s8">inf</span>)) },</p>
<p class="p22"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// estimate end time</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>maxTime: 20,</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>att: 0.2,</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>rel: 5,</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>doneAction: 2</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>),</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>0.2,</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>0.1</p>
<p class="p23"><span class="Apple-tab-span">	</span>);</p>
<p class="p23">}.play</p>
<p class="p23">)</p>
<p class="p9"><br></p>
<p class="p23">(</p>
<p class="p23">b.do(<span class="s6">_</span>.free);</p>
<p class="p23">z.do(<span class="s6">_</span>.free);</p>
<p class="p23">)</p>
<p class="p9"><br></p>
<p class="p22">// It's of course unproblematic – and still quasi realtime – to fully a analyse<span class="Apple-converted-space"> </span></p>
<p class="p22">// a snippet of sound with ZeroXBufWr before freely using ZeroXBufRd in the same synth</p>
<p class="p9"><br></p>
<p class="p9"><br></p>
<p class="p9"><br></p>
<p class="p14"><b>Ex.7) Adjusting zero crossings</b></p>
<p class="p9"><br></p>
<p class="p9"><br></p>
<p class="p22">// In general a half waveset isn't totally unipolar:</p>
<p class="p22">// Zero crossing indices indicate the change of the sign of a signal,</p>
<p class="p22">// so with this convention the last sample of the half waveset itself</p>
<p class="p22">// has a different sign.</p>
<p class="p9"><br></p>
<p class="p22">// This can have the consequence that, depending on the playback rate,</p>
<p class="p22">// sawtooth-like effects might occur. Such artefacts can be circumvented by</p>
<p class="p22">// adjusting buffer values at zero crossing indices to 0,</p>
<p class="p22">// so playback of (half) wavesets is smoothened, especially with extreme rate values.</p>
<p class="p9"><br></p>
<p class="p9"><br></p>
<p class="p23">(</p>
<p class="p23">p = <span class="s6">Platform</span>.resourceDir +/+ <span class="s9">"sounds/a11wlk01.wav"</span>;</p>
<p class="p23">b = <span class="s6">Buffer</span>.read(s, p);</p>
<p class="p23">z = <span class="s6">Buffer</span>.alloc(s, 100000);</p>
<p class="p23">)</p>
<p class="p9"><br></p>
<p class="p22">// analyse buffer</p>
<p class="p23">(</p>
<p class="p23">{</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="s7">var</span> src = <span class="s6">PlayBuf</span>.ar(1, b, <span class="s6">BufRateScale</span>.ir(b), doneAction: 2);</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="s6">ZeroXBufWr</span>.ar(src, b, z, startWithZeroX: 0, doneAction: 2);</p>
<p class="p23">}.play</p>
<p class="p23">)</p>
<p class="p9"><br></p>
<p class="p22">// this half waveset clearly shows the effect</p>
<p class="p22">// (tested with samplerate 44100)</p>
<p class="p9"><br></p>
<p class="p23">s.scope</p>
<p class="p9"><br></p>
<p class="p23">x = { <span class="s6">ZeroXBufRd</span>.ar(b, z, <span class="s8">nil</span>, 220, rate: 0.1) * 2 }.play</p>
<p class="p9"><br></p>
<p class="p9"><br></p>
<p class="p22">// adjust zeros, also works with arrays of Buffers</p>
<p class="p22">// you can apply it while running, it might take a moment though</p>
<p class="p9"><br></p>
<p class="p23">b.adjustZeroXs(z)</p>
<p class="p9"><br></p>
<p class="p23">x.release</p>
<p class="p9"><br></p>
<p class="p9"><br></p>
<p class="p22">// alternatively adjusting zero crossings can be chosen as option with analysis:</p>
<p class="p22">// set flag 'adjustZeroXs' to 1</p>
<p class="p9"><br></p>
<p class="p9"><br></p>
<p class="p23">(</p>
<p class="p23">p = <span class="s6">Platform</span>.resourceDir +/+ <span class="s9">"sounds/a11wlk01.wav"</span>;</p>
<p class="p23">b = <span class="s6">Buffer</span>.read(s, p);</p>
<p class="p23">z = <span class="s6">Buffer</span>.alloc(s, 100000);</p>
<p class="p23">)</p>
<p class="p9"><br></p>
<p class="p22">// analyse buffer</p>
<p class="p9"><br></p>
<p class="p23">(</p>
<p class="p23">{</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="s7">var</span> src = <span class="s6">PlayBuf</span>.ar(1, b, <span class="s6">BufRateScale</span>.ir(b), doneAction: 2);</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="s6">ZeroXBufWr</span>.ar(src, b, z, startWithZeroX: 0, adjustZeroXs: 1, doneAction: 2);</p>
<p class="p23">}.play</p>
<p class="p23">)</p>
<p class="p9"><br></p>
<p class="p23">s.scope</p>
<p class="p9"><br></p>
<p class="p23">x = { <span class="s6">ZeroXBufRd</span>.ar(b, z, <span class="s8">nil</span>, 220, rate: 0.1) * 2 }.play</p>
<p class="p9"><br></p>
<p class="p23">x.release</p>
<p class="p9"><br></p>
<p class="p9"><br></p>
<p class="p22">// the flag 'adjustZeroXs' can also be set to 2</p>
<p class="p22">// in this case zero crossings have a minimum distance of 2 samples</p>
<p class="p22">// This goes along with ZeroXBufRd's convention to play one half waveset with a minimum length of 2 samples</p>
<p class="p22">// (otherwise it couldn't act as a trigger)</p>
<p class="p9"><br></p>
<p class="p22">// the difference can be observed with fast switches between signs like with WhiteNoise</p>
<p class="p9"><br></p>
<p class="p23">(</p>
<p class="p23">b = <span class="s6">Buffer</span>.alloc(s, 2000);</p>
<p class="p23">z = <span class="s6">Buffer</span>.alloc(s, 2000);</p>
<p class="p23">)</p>
<p class="p9"><br></p>
<p class="p23">(</p>
<p class="p23">{</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="s7">var</span> src = <span class="s6">WhiteNoise</span>.ar();</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="s6">ZeroXBufWr</span>.ar(src, b, z, startWithZeroX: 0, adjustZeroXs: 1, doneAction: 2) * 0.2;</p>
<p class="p23">}.play</p>
<p class="p23">)</p>
<p class="p9"><br></p>
<p class="p23">s.scope</p>
<p class="p9"><br></p>
<p class="p9"><br></p>
<p class="p22">// this generates a more pulsar-like waveform with adjacent zero crossings,</p>
<p class="p22">// note that transitions to flat sections are smoothened by cubic interpolation</p>
<p class="p9"><br></p>
<p class="p23">x = { <span class="s6">ZeroXBufRd</span>.ar(b, z, <span class="s8">nil</span>, <span class="s6">Dseq</span>((0..50), <span class="s8">inf</span>), rate: 0.03) * 0.5 }.play</p>
<p class="p9"><br></p>
<p class="p23">x.release</p>
<p class="p9"><br></p>
<p class="p9"><br></p>
<p class="p22">// there are no flat sections with 'adjustZeroXs' set to 2</p>
<p class="p9"><br></p>
<p class="p23">(</p>
<p class="p23">b.zero;</p>
<p class="p23">z.zero;</p>
<p class="p23">)</p>
<p class="p9"><br></p>
<p class="p23">(</p>
<p class="p23">{</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="s7">var</span> src = <span class="s6">WhiteNoise</span>.ar();</p>
<p class="p23"><span class="Apple-tab-span">	</span><span class="s6">ZeroXBufWr</span>.ar(src, b, z, startWithZeroX: 0, adjustZeroXs: 2, doneAction: 2) * 0.2;</p>
<p class="p23">}.play</p>
<p class="p23">)</p>
<p class="p9"><br></p>
<p class="p9"><br></p>
<p class="p23">x = { <span class="s6">ZeroXBufRd</span>.ar(b, z, <span class="s8">nil</span>, <span class="s6">Dseq</span>((0..50), <span class="s8">inf</span>), rate: 0.03) * 0.5 }.play</p>
<p class="p9"><br></p>
<p class="p23">x.release</p>
<p class="p9"><br></p>
<p class="p25"><br></p>
<p class="p9"><br></p>
<p class="p14"><b>Ex.8) Granulation with movement through a buffer</b></p>
<p class="p19"><br></p>
<p class="p22">// See Buffer Granulation tutorial, Ex. 1g</p>
<p class="p19"><br></p>
<p class="p19"><br></p>
</body>
</html>
