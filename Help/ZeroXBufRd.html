<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title></title>
<meta name="Generator" content="Cocoa HTML Writer">
<meta name="CocoaVersion" content="1348.17">
<style type="text/css">
p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; color: #000000; -webkit-text-stroke: #000000}
p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; color: #0000ee; -webkit-text-stroke: #0000ee}
p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #000000; -webkit-text-stroke: #000000}
p.p4 {margin: 0.0px 0.0px 0.0px 27.0px; text-indent: -27.0px; font: 12.0px Helvetica; color: #000000; -webkit-text-stroke: #000000}
p.p5 {margin: 0.0px 0.0px 0.0px 27.0px; text-indent: -27.0px; font: 12.0px Helvetica; color: #000000; -webkit-text-stroke: #000000; min-height: 14.0px}
p.p6 {margin: 0.0px 0.0px 0.0px 27.0px; text-indent: -27.0px; font: 12.0px Helvetica; color: #0000ee; -webkit-text-stroke: #0000ee}
p.p7 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Helvetica; color: #000000; -webkit-text-stroke: #000000}
p.p8 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 9.0px Monaco; color: #000000; -webkit-text-stroke: #000000}
p.p9 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 12.0px Helvetica; color: #000000; -webkit-text-stroke: #000000}
p.p10 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 12.0px Helvetica; color: #000000; -webkit-text-stroke: #000000; min-height: 14.0px}
p.p11 {margin: 0.0px 0.0px 0.0px 85.0px; text-indent: -85.0px; font: 12.0px Helvetica; color: #000000; -webkit-text-stroke: #000000}
p.p12 {margin: 0.0px 0.0px 0.0px 85.0px; text-indent: -85.0px; font: 12.0px Helvetica; color: #000000; -webkit-text-stroke: #000000; min-height: 14.0px}
p.p13 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 14.0px Helvetica; color: #000000; -webkit-text-stroke: #000000}
p.p14 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Monaco; color: #000000; -webkit-text-stroke: #000000}
p.p15 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #cd1c00; -webkit-text-stroke: #cd1c00}
p.p16 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #0326cb; -webkit-text-stroke: #0326cb}
p.p17 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #000000; -webkit-text-stroke: #000000; min-height: 12.0px}
p.p18 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 9.0px Monaco; color: #cd1c00; -webkit-text-stroke: #cd1c00}
p.p19 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 9.0px Monaco; color: #0326cb; -webkit-text-stroke: #0326cb}
p.p20 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 9.0px Monaco; color: #000000; -webkit-text-stroke: #cd1c00}
p.p21 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 9.0px Monaco; color: #ff7c00; -webkit-text-stroke: #cd1c00}
p.p22 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 9.0px Monaco; color: #737373; -webkit-text-stroke: #cd1c00}
p.p23 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 9.0px Monaco; color: #0326cb; -webkit-text-stroke: #cd1c00}
p.p24 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 9.0px Monaco; color: #ff7c00; -webkit-text-stroke: #ff7c00}
p.p25 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 9.0px Monaco; color: #737373; -webkit-text-stroke: #737373}
span.s1 {font: 18.0px Helvetica; font-kerning: none}
span.s2 {font-kerning: none}
span.s3 {font-kerning: none; color: #000000; -webkit-text-stroke: 0px #000000}
span.s4 {text-decoration: underline ; font-kerning: none; color: #0000ee; -webkit-text-stroke: 0px #0000ee}
span.s5 {text-decoration: underline ; font-kerning: none; color: #042eee; -webkit-text-stroke: 0px #042eee}
span.s6 {font-kerning: none; color: #00bbff; -webkit-text-stroke: 0px #00bbff}
span.s7 {font-kerning: none; color: #0326cb; -webkit-text-stroke: 0px #0326cb}
span.s8 {font-kerning: none; color: #0433ff; -webkit-text-stroke: 0px #0433ff}
span.s9 {font-kerning: none; color: #434ccb; -webkit-text-stroke: 0px #434ccb}
span.s10 {font-kerning: none; color: #737373; -webkit-text-stroke: 0px #737373}
span.s11 {font-kerning: none; color: #0326cb}
span.s12 {font-kerning: none; color: #737373}
span.s13 {font-kerning: none; color: #0433ff}
span.s14 {font-kerning: none; color: #ff7c00}
span.s15 {font-kerning: none; color: #000000}
span.s16 {font-kerning: none; color: #434ccb}
span.s17 {font: 14.0px Helvetica; font-kerning: none; -webkit-text-stroke: 0px #000000}
span.s18 {font-kerning: none; color: #ff7c00; -webkit-text-stroke: 0px #ff7c00}
span.Apple-tab-span {white-space:pre}
</style>
</head>
<body>
<p class="p1"><span class="s1"><b>ZeroXBufRd<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></b></span><span class="s2"><b>reads consecutive sequences of segments between zero crossings from one or more buffers with demand-rate control</b></span></p>
<p class="p1"><span class="s2"><br>
</span></p>
<p class="p2"><span class="s3"><b>Part of:</b> <a href="../miSCellaneous.html"><span class="s4">miSCellaneous</span></a></span></p>
<p class="p1"><span class="s2"><br>
</span></p>
<p class="p1"><span class="s2"><b>Inherits from: UGen</b></span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p1"><span class="s2">ZeroXBufRd is for consecutive reading of segments between zero crossings (half wavesets) from one or more buffers, whereby several reading and processing parameters can be sequenced with demand rate ugens. Full waveset sequences can so be generated as a special case. It needs analysis data prepared with <a href="../ZeroXBufWr.html"><span class="s5">ZeroXBufWr</span></a>. For triggering possibly overlapped (half) wavesets see <a href="../TZeroXBufRd.html"><span class="s5">TZeroXBufRd</span></a>. ZeroXBufRd / TZeroXBufRd can be used for a number of synthesis / processing techniques in a field between wavesets [1, 4, 5], pulsar synthesis [1, 3], buffer modulation and rectification (which are both a kind of waveshaping) and stochastic concatenation methods [2, 6]. There are already existing SC waveset implementations like Alberto de Campo's Wavesets quark (<a href="https://github.com/supercollider-quarks/quarks"><span class="s5">https://github.com/supercollider-quarks/quarks</span></a>) and Olaf Hochherz's SPList (<a href="https://github.com/olafklingt/SPList"><span class="s5">https://github.com/olafklingt/SPList</span></a>), which do language-side analysis and Fabian Seidl's RTWaveSets plugin (<a href="https://github.com/tai-studio/RTWaveSets"><span class="s5">https://github.com/tai-studio/RTWaveSets</span></a>). My focus has been server-side analysis and demand rate ugen control of half waveset parameters as well as multichannel and buffer switch options. Realtime control while analysis is possible, as long as reading is only refering to already analysed sections, but clearly most flexibility is given with a fully analysed buffer, which can also be done in quasi realtime.</span></p>
<p class="p1"><span class="s2"><br>
</span></p>
<p class="p1"><span class="s2"><b>NOTE: </b>Depending on the multichannel sizes and the options used (rate and dir sequencing) it might be necessary to increase server resources, i.e. the number of interconnect buffers and / or memory size (e.g. s.options.numWireBufs = 256; s.options.memSize = 8192 * 32; s.reboot). Because of overlappings this is more relevant with TZeroXBufRd than with ZeroXBufRd.</span></p>
<p class="p1"><span class="s2"><br>
</span></p>
<p class="p1"><span class="s2"><b>NOTE: </b>Often it pays to adjust zero crossings in the sound buffer effectively to 0, that way sawtooth-like interpolation artefacts can be avoided. See Ex. 7 below.</span></p>
<p class="p1"><span class="s2"><br>
</span></p>
<p class="p1"><span class="s2"><b>NOTE: </b>The reading of consecutive half wavesets is implemented with Sweep and retriggering. For that reason each played back half waveset has a minimum length of 2 samples. In the case of adjusted zero crossings that immediately follow each other this can lead to flat sections of a few samples length. Normally this is irrelevant, but you might check setting ZeroXBufWr's adjustZeroXs flag to 2, see the example there and below.</span></p>
<p class="p1"><span class="s2"><br>
</span></p>
<p class="p1"><span class="s2"><b>NOTE: </b>Demand rate UGens in ZeroXBufRd / TZeroXBufRd must always use inf as repeats arg, this is of course not necessary for nested ones. You might pass a length arg though (Ex. 5).</span></p>
<p class="p1"><span class="s2"><br>
</span></p>
<p class="p1"><span class="s2"><b>NOTE: </b>For avoiding too long half wavesets it might be useful to apply LeakDC resp. a high pass filter before analysis.</span></p>
<p class="p1"><span class="s2"><br>
</span></p>
<p class="p1"><span class="s2"><b>NOTE: </b>In rare cases I noticed corrupted buffers in multi buffer examples for no obvious reason.</span></p>
<p class="p1"><span class="s2"><br>
</span></p>
<p class="p1"><span class="s2"><b>NOTE: </b>For full functionality at least SC 3.7 is recommended (rate sequencing doesn't work in 3.6)</span></p>
<p class="p1"><span class="s2"><br>
</span></p>
<p class="p1"><span class="s2"><br>
</span></p>
<p class="p1"><span class="s2"><b>CREDITS: </b>Thanks to Tommaso Settimi for an inspiring discussion, which gave me a nudge to tackle these classes.<span class="Apple-converted-space"> </span></span></p>
<p class="p1"><span class="s2"><br>
</span></p>
<p class="p1"><span class="s2"><br>
</span></p>
<p class="p1"><span class="s2"><b>REFERENCES:</b></span></p>
<p class="p1"><span class="s2"><br>
</span></p>
<p class="p4"><span class="s2">[1]<span class="Apple-tab-span">	</span>de Campo, Alberto. "Microsound" In: Wilson, S., Cottle, D. and Collins, N. (eds). 2011.<span class="Apple-converted-space"> </span></span></p>
<p class="p4"><span class="s2"><span class="Apple-tab-span">	</span><i>The SuperCollider Book</i>. Cambridge, MA: MIT Press, 463-504.</span></p>
<p class="p5"><span class="s2"><span class="Apple-tab-span">	</span></span></p>
<p class="p4"><span class="s2">[2]<span class="Apple-tab-span">	</span>Luque, Sergio (2006). <i>Stochastic Synthesis, Origins and Extensions</i>. Institute of Sonology, Royal Conservatory, The Netherlands.<span class="Apple-converted-space"> </span></span></p>
<p class="p6"><span class="s3"><span class="Apple-tab-span">	</span><a href="http://sergioluque.com/"><span class="s4">http://sergioluque.com</span></a></span></p>
<p class="p4"><span class="s2"><br>
</span></p>
<p class="p4"><span class="s2">[3]<span class="Apple-tab-span">	</span>Roads, Curtis (2001). <i>Microsound</i>. Cambridge, MA: MIT Press.</span></p>
<p class="p5"><span class="s2"><span class="Apple-tab-span">	</span></span></p>
<p class="p4"><span class="s2">[4]<span class="Apple-tab-span">	</span>Seidl, Fabian (2016). <i>Granularsynthese mit Wavesets für Live-Anwendungen</i>. Master Thesis, TU Berlin.</span></p>
<p class="p6"><span class="s3"><span class="Apple-tab-span">	</span><a href="https://www2.ak.tu-berlin.de/~akgroup/ak_pub/abschlussarbeiten/2016/Seidl_MasA.pdf"><span class="s4">https://www2.ak.tu-berlin.de/~akgroup/ak_pub/abschlussarbeiten/2016/Seidl_MasA.pdf</span></a></span></p>
<p class="p4"><span class="s2"><br>
</span></p>
<p class="p4"><span class="s2">[5]<span class="Apple-tab-span">	</span>Wishart, Trevor (1994). <i>Audible Design</i>. York: Orpheus The Pantomime Ltd.<span class="Apple-converted-space"> </span></span></p>
<p class="p4"><span class="s2"><br>
</span></p>
<p class="p4"><span class="s2">[6]<span class="Apple-tab-span">	</span>Xenakis, Iannis (1992). <i>Formalized Music</i>. Hillsdale, NY: Pendragon Press, 2nd Revised edition.</span></p>
<p class="p4"><span class="s2"><br>
</span></p>
<p class="p4"><span class="s2"><br>
</span></p>
<p class="p1"><span class="s2"><br>
</span></p>
<p class="p2"><span class="s3"><b>See also: </b><a href="../TZeroXBufRd.html"><span class="s4">TZeroXBufRd</span></a>,<b> </b><a href="../ZeroXBufWr.html"><span class="s4">ZeroXBufWr</span></a>,<b> </b><a href="../DX suite.html"><span class="s4">DX suite</span></a>,<b> </b><a href="../DXMix.html"><span class="s4">DXMix</span></a>, <a href="../DXMixIn.html"><span class="s4">DXMixIn</span></a>, <a href="../DXEnvFan.html"><span class="s4">DXEnvFan</span></a>,<b> </b><a href="../DXEnvFanOut.html"><span class="s4">DXEnvFanOut</span></a>, <a href="../DXFanOut.html"><span class="s4">DXFanOut</span></a>, <a href="../Buffer Granulation.html"><span class="s4">Buffer Granulation</span></a>, <a href="../Live Granulation.html"><span class="s4">Live Granulation</span></a>, <a href="../PbindFx.html"><span class="s4">PbindFx</span></a></span><span class="s6">,</span><span class="s3"> <a href="../kitchen studies.html"><span class="s4">kitchen studies</span></a></span></p>
<p class="p1"><span class="s2"><br>
</span></p>
<p class="p1"><span class="s2"><br>
</span></p>
<p class="p7"><span class="s2"><b>Creation / Class Methods</b></span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p9"><span class="s2"><b><span class="Apple-tab-span">	</span>*ar (sndBuf, zeroXBuf, bufMix, zeroX = 0, power = 1, mul = 1, add = 0, rate = 1, rateMul = 1, dir = 1, interpl = 4, dUniqueBufSize = 1048576,</b></span></p>
<p class="p9"><span class="s2"><b><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>length = inf, maxTime = inf, att = 0, rel = 0, curve = -4, doneAction = 0)</b></span></p>
<p class="p10"><span class="s2"><b><span class="Apple-tab-span">	</span></b></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>sndBuf </b>- Buffer or SequenceableCollection of Buffers to read the data from, data must correspond to <b>zeroXBuf</b>.</span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>zeroXBuf </b>- Analysis Buffer resp. SequenceableCollection of such, prepared with <a href="../ZeroXBufWr.html"><span class="s5">ZeroXBufWr</span></a>.<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Must refer to data passed to <b>sndBuf</b>.</span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>bufMix </b>- A Number indicating the <b>sndBuf</b> index, a demand rate or other ugens returning <b>sndBuf</b> indices or<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>a SequenceableCollection of such. In contrast to other args combinations of demand rate and normal ugens are not valid.<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If <b>bufMix </b>equals<b> </b>nil (default) the size of the returned signal equals the size of <b>sndBuf</b>,</span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>otherwise it equals its own size.</span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>zeroX </b>- A Number indicating the index in <b>zeroXBuf</b>, a demand rate or other ugens returning <b>zeroXBuf</b> indices or<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>a SequenceableCollection of such.</span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If in this case the overall multichannel size determined by <b>sndBuf </b>or<b> bufMix </b>is larger than the size of <b>zeroX</b></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>and the latter contains demand rate ugens, they must all be wrapped into Functions for being used more than once.</span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 0.</span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>power </b>- Used for processing the buffer signal according to the formula: sig ** <b>power</b> * <b>mul</b> + <b>add</b> per half waveset.<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Must be a positive Number, a demand rate or other ugens returning <b>power </b>values or<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>a SequenceableCollection of such.</span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If in this case the overall multichannel size determined by <b>sndBuf </b>or<b> bufMix </b>is larger than the size of <b>power</b></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>and the latter contains demand rate ugens, they must all be wrapped into Functions for being used more than once.</span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 1.</span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>mul </b>- Used for processing the buffer signal according to the formula: sig ** <b>power</b> * <b>mul</b> + <b>add</b> per half waveset.<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Must be a Number, a demand rate or other ugens returning <b>mul </b>values or<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>a SequenceableCollection of such.</span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If in this case the overall multichannel size determined by <b>sndBuf </b>or<b> bufMix </b>is larger than the size of <b>mul</b></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>and the latter contains demand rate ugens, they must all be wrapped into Functions for being used more than once.</span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 1.<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>add </b>- Used for processing the buffer signal according to the formula: sig ** <b>power</b> * <b>mul</b> + <b>add</b> per half waveset.<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Must be a Number, a demand rate or other ugens returning <b>add </b>values or<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>a SequenceableCollection of such.</span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If in this case the overall multichannel size determined by <b>sndBuf </b>or<b> bufMix </b>is larger than the size of <b>add</b></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>and the latter contains demand rate ugens, they must all be wrapped into Functions for being used more than once.</span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 0.<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>rate </b>- Determines the playback rate per half waveset together with <b>rateMul</b>.<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Must be a positive Number, a demand rate or other ugens returning <b>rate </b>values or a SequenceableCollection of such.<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If in this case the overall multichannel size determined by <b>sndBuf </b>or<b> bufMix </b>is larger than the size of <b>rate</b></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>and the latter contains demand rate ugens, they must all be wrapped into Functions for being used more than once.</span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>In contrast to other args combinations of demand rate and normal ugens are not valid for implementational reasons.<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Though you can pass a demand rate ugen here and a normal ugen to <b>rateMul </b>(or vice versa) which are then multiplied per half waveset<b>.</b></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 1.<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>rateMul </b>- Determines the playback rate per half waveset together with <b>rate</b>.<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Must be a positive Number, a demand rate or other ugens returning <b>rateMul </b>values or a SequenceableCollection of such.<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If in this case the overall multichannel size determined by <b>sndBuf </b>or<b> bufMix </b>is larger than the size of <b>rateMul</b></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>and the latter contains demand rate ugens, they must all be wrapped into Functions for being used more than once.</span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>In contrast to other args combinations of demand rate and normal ugens are not valid for implementational reasons.<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Though you can pass a normal ugen here and a demand rate ugen to <b>rate </b>(or vice versa) which are then multiplied per half waveset<b>.</b></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 1.<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>dir </b>- Determines the playback direction of half wavesets.<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Must be +1 or -1, a demand rate or other ugens returning <b>dir </b>values or<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>a SequenceableCollection of such.<span class="Apple-converted-space">  </span>If in this case the overall multichannel size determined by <b>sndBuf </b>or<b> bufMix </b>is<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>larger than the size of <b>dir</b> and the latter contains demand rate ugens, they must all be wrapped into Functions for<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>being used more than once. In contrast to other args combinations of demand rate and normal ugens are not valid.</span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 1.<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>interpl </b>- Determines the interpolation type for the BufRd ugens.<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Must equal 1 (no), 2 (linear) or 4 (cubic) or a SequenceableCollection of these numbers.</span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 4.<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>dUniqueBufSize </b>- Determines the buffer size for Dunique objects which have to be used in the case</span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>of demand rate ugens passed to <b>rate</b>, <b>dir</b> or <b>bufMix</b>. See Ex.2.</span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Must be an Integer or a SequenceableCollection of Integers.</span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 1048576.<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>length </b>- Determines the number of triggers before release of the overall asr envelope.<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Can be a Sequenceable Collection too. Overruled by <b>maxTime</b> if this is reached before.</span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to inf.<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>maxTime </b>- Determines the time before release of the overall asr envelope.<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Can be a Sequenceable Collection too. Overruled by <b>length</b> if this is reached before.</span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to inf.<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>att </b>- Attack time of overall asr envelope or SequenceableCollection thereof.<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 0.<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>rel </b>- Release time of overall asr envelope or SequenceableCollection thereof. <span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 0.<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>curve </b>- Curve of overall asr envelope or SequenceableCollection thereof. <span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to -4.<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>doneAction </b>- Done action of overall asr envelope or SequenceableCollection thereof. <span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 0.<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></span></p>
<p class="p12"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></p>
<p class="p10"><span class="s2"><b><span class="Apple-tab-span">	</span></b></span></p>
<p class="p9"><span class="s2"><br>
</span></p>
<p class="p13"><span class="s2"><b>Examples</b></span></p>
<p class="p14"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">(</span></p>
<p class="p15"><span class="s2">// boot with extended resources, might be needed for some examples</span></p>
<p class="p3"><span class="s2">s = </span><span class="s7">Server</span><span class="s2">.local;</span></p>
<p class="p3"><span class="s7">Server</span><span class="s2">.default = s;</span></p>
<p class="p3"><span class="s2">s.options.numWireBufs = 256;<span class="Apple-converted-space"> </span></span></p>
<p class="p3"><span class="s2">s.options.memSize = 8192 * 32;<span class="Apple-converted-space"> </span></span></p>
<p class="p3"><span class="s2">s.reboot;</span></p>
<p class="p3"><span class="s2">)</span></p>
<p class="p7"><span class="s2"><br>
</span></p>
<p class="p13"><span class="s2"><br>
</span></p>
<p class="p13"><span class="s2"><b>Ex.1) Basic usage</b></span></p>
<p class="p10"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></p>
<p class="p15"><span class="s2">// prepare two short buffers for audio and zero crossing data</span></p>
<p class="p15"><span class="s2">// the size of needed zeroX data space can be roughly estimated</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">(</span></p>
<p class="p3"><span class="s2">b = </span><span class="s7">Buffer</span><span class="s2">.alloc(s, 2000);</span></p>
<p class="p3"><span class="s2">z = </span><span class="s7">Buffer</span><span class="s2">.alloc(s, 200);</span></p>
<p class="p3"><span class="s2">)</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// analyse a short snippet of ring modulation</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">(</span></p>
<p class="p3"><span class="s2">{</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s8">var</span><span class="s2"> src = </span><span class="s7">SinOsc</span><span class="s2">.ar(300) * </span><span class="s7">SinOsc</span><span class="s2">.ar(120) + </span><span class="s7">SinOsc</span><span class="s2">.ar(30) * 0.1;</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s7">ZeroXBufWr</span><span class="s2">.ar(src, b, z, startWithZeroX: 1, doneAction: 2);</span></p>
<p class="p16"><span class="s3"><span class="Apple-tab-span">	</span></span><span class="s2">Silent</span><span class="s3">.ar</span></p>
<p class="p3"><span class="s2">}.play</span></p>
<p class="p3"><span class="s2">)</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// check the waveform</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">b.plot</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// loop 3rd half waveset</span></p>
<p class="p15"><span class="s2">// compare plot and scope</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z, zeroX: 2) }.play</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">s.scope</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// loop a whole waveset</span></p>
<p class="p15"><span class="s2">// demand rate ugens in ZeroXBufRd should always use inf as repeats arg</span></p>
<p class="p17"><span class="s2"><span class="Apple-converted-space"> </span></span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z, zeroX: </span><span class="s7">Dseq</span><span class="s2">([1, 2], </span><span class="s9">inf</span><span class="s2">)) }.play</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// Note that the distance between zero crossings can be very short,</span></p>
<p class="p15"><span class="s2">// here the half waveset at index 5 (735-740) has a length of only 5 samples and the amplitude is low.</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// zero crossing indices</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">z.loadToFloatArray(action: { </span><span class="s8">|b|</span><span class="s2"> b.postln })</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// the signal is hardly audible, but there as freqscope shows</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z, zeroX: 5) }.play</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">s.freqscope</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// loop a group of 3 wavesets</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z, zeroX: </span><span class="s7">Dseq</span><span class="s2">((1..6), </span><span class="s9">inf</span><span class="s2">)) }.play</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// sequence multiplier for half wavesets</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z, zeroX: </span><span class="s7">Dseq</span><span class="s2">([1, 2], </span><span class="s9">inf</span><span class="s2">), mul: </span><span class="s7">Dseq</span><span class="s2">([1, 0.2], </span><span class="s9">inf</span><span class="s2">)) }.play</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// mul can be used for rectifying effects</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z, zeroX: </span><span class="s7">Dseq</span><span class="s2">((1..2), </span><span class="s9">inf</span><span class="s2">), mul: </span><span class="s7">Dseq</span><span class="s2">([0, 1, 1], </span><span class="s9">inf</span><span class="s2">)) }.play</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// add an offset sequence, this results in a pulse-like effect</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z, zeroX: </span><span class="s7">Dseq</span><span class="s2">([1, 2], </span><span class="s9">inf</span><span class="s2">), add: </span><span class="s7">Dseq</span><span class="s2">([-0.05, 0.05], </span><span class="s9">inf</span><span class="s2">)) * 0.5 }.play</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z, zeroX: </span><span class="s7">Dseq</span><span class="s2">([1, 2], </span><span class="s9">inf</span><span class="s2">), add: </span><span class="s7">Dseq</span><span class="s2">([0.05, -0.05], </span><span class="s9">inf</span><span class="s2">)) * 0.5 }.play</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// half wavesets can also get a power,</span></p>
<p class="p15"><span class="s2">// per waveset the signal is calculated according to</span></p>
<p class="p15"><span class="s2">// ((sig ** power) * mul) + add</span></p>
<p class="p15"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// be careful with this arg moving away from 1 !<span class="Apple-converted-space"> </span></span></p>
<p class="p15"><span class="s2">// high power values can result in loud signals if the source has values outside [-1, 1] and</span></p>
<p class="p15"><span class="s2">// small power values can also become loud with source values near zero</span></p>
<p class="p15"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z, zeroX: </span><span class="s7">Dseq</span><span class="s2">([1, 2], </span><span class="s9">inf</span><span class="s2">), power: 0.7) }.play</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z, zeroX: </span><span class="s7">Dseq</span><span class="s2">([1, 2], </span><span class="s9">inf</span><span class="s2">), power: </span><span class="s7">Dseq</span><span class="s2">([0.8, 1.7, 1], </span><span class="s9">inf</span><span class="s2">)) }.play</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2"><br>
</span></p>
<p class="p13"><span class="s2"><b>Ex.2) The 'rate' and 'dir' args</b></span></p>
<p class="p13"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// needs Buffers from Ex.1</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">s.scope</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// playback rates can be defined generally ...</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z, zeroX: </span><span class="s7">Dseq</span><span class="s2">([1, 2], </span><span class="s9">inf</span><span class="s2">), rate: 2.5) }.play</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// ... or as sequence</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z, zeroX: </span><span class="s7">Dseq</span><span class="s2">([1, 2], </span><span class="s9">inf</span><span class="s2">), rate: </span><span class="s7">Dseq</span><span class="s2">((1..3), </span><span class="s9">inf</span><span class="s2">)) }.play</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// slightly different: here the whole waveset gets one rate</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z, zeroX: </span><span class="s7">Dseq</span><span class="s2">([1, 2], </span><span class="s9">inf</span><span class="s2">), rate: </span><span class="s7">Dstutter</span><span class="s2">(2, </span><span class="s7">Dseq</span><span class="s2">((1..3), </span><span class="s9">inf</span><span class="s2">))) }.play</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// with the dir argument set to -1 the half wave set is reversed</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z, zeroX: 7) }.play</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// compare scope, no audible difference here</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z, zeroX: 7, dir: -1) }.play</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// dir can also be sequenced</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z, zeroX: 7, dir: </span><span class="s7">Dseq</span><span class="s2">([1, 1, -1], </span><span class="s9">inf</span><span class="s2">)) }.play</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p15"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// When demand rate ugens are used for 'rate' or 'dir' args ZeroXBufRd employs Dunique objects.</span></p>
<p class="p15"><span class="s2">// This means that Buffers have to be allocated for counting, and if the Buffer is full</span></p>
<p class="p15"><span class="s2">// the synthesis fails. By default a value of 1048576 is defined for 'dUniqueBufSize'.</span></p>
<p class="p15"><span class="s2">// This should be sufficient for at least some minutes auf audio in average use cases.</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// However with very fast triggering you might want to pass a higher value.</span></p>
<p class="p15"><span class="s2">// With multichannel applications it might be necessary then to run the server with higher memSize.</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// With a deliberately bad (low) size, sequencing fails after a second</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z, zeroX: 1, rate: </span><span class="s7">Dseq</span><span class="s2">([1, 2], </span><span class="s9">inf</span><span class="s2">), dUniqueBufSize: 1024) }.play</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// From low values you can roughly estimate the needed dUniqueBufSize to safely run your application</span></p>
<p class="p15"><span class="s2">// for a given time</span></p>
<p class="p15"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p13"><span class="s2"><br>
</span></p>
<p class="p13"><span class="s2"><br>
</span></p>
<p class="p13"><span class="s2"><b>Ex.3) Passing ordinary UGens as args</b></span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// needs Buffers from Ex.1</span></p>
<p class="p15"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// values are sampled and hold for the duration of the segments</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">s.scope</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z, zeroX: </span><span class="s7">SinOsc</span><span class="s2">.ar(</span><span class="s7">SinOsc</span><span class="s2">.ar(0.1).range(0.2, 5)).range(1, 15)) }.play</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// more fun with moving rates</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">(</span></p>
<p class="p3"><span class="s2">x = {<span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s3"><span class="Apple-tab-span">	</span></span><span class="s2">ZeroXBufRd</span><span class="s3">.ar(</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>b, z,<span class="Apple-converted-space"> </span></span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>zeroX: </span><span class="s7">LFDNoise3</span><span class="s2">.ar(</span><span class="s7">SinOsc</span><span class="s2">.ar(0.1).range(1, 10)).range(1, 15),</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>rate: </span><span class="s7">SinOsc</span><span class="s2">.ar(</span><span class="s7">SinOsc</span><span class="s2">.ar(0.3).range(0.2, 5)).exprange(1, 5)</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span>) ! 2</span></p>
<p class="p3"><span class="s2">}.play</span></p>
<p class="p3"><span class="s2">)</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// warp effect with accelerating rates</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">(</span></p>
<p class="p3"><span class="s2">x = {<span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s3"><span class="Apple-tab-span">	</span></span><span class="s2">ZeroXBufRd</span><span class="s3">.ar(</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>b, z,<span class="Apple-converted-space"> </span></span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>zeroX: </span><span class="s7">LFDNoise3</span><span class="s2">.ar(</span><span class="s7">SinOsc</span><span class="s2">.ar(0.1).range(1, 10)).range(1, 15),</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>rate: </span><span class="s7">Dseq</span><span class="s2">((1..50) / 20 + 0.5, </span><span class="s9">inf</span><span class="s2">)</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span>) ! 2</span></p>
<p class="p3"><span class="s2">}.play</span></p>
<p class="p3"><span class="s2">)</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// also combinations of demand rate and ordinary ugens are possible</span></p>
<p class="p15"><span class="s2">// though with the exception of rate, dir and bufMix args</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">(</span></p>
<p class="p3"><span class="s2">x = {<span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s3"><span class="Apple-tab-span">	</span></span><span class="s2">ZeroXBufRd</span><span class="s3">.ar(</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>b, z,<span class="Apple-converted-space"> </span></span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>zeroX: </span><span class="s7">LFDNoise3</span><span class="s2">.ar(</span><span class="s7">SinOsc</span><span class="s2">.ar(0.1).range(1, 10)).range(1, 15),</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>rate: </span><span class="s7">Dstutter</span><span class="s2">(</span><span class="s7">Dwhite</span><span class="s2">(10, 100), </span><span class="s7">Dwhite</span><span class="s2">(0.5, 2)),</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>mul: </span><span class="s7">Dseq</span><span class="s2">([0.2, 0.2, 1], </span><span class="s9">inf</span><span class="s2">) * </span><span class="s7">LFDNoise3</span><span class="s2">.ar(5).range(1, 5)</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span>) ! 2</span></p>
<p class="p3"><span class="s2">}.play</span></p>
<p class="p3"><span class="s2">)</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// for combinations of normal and demand ugens with the rate arg rateMul can be used</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">(</span></p>
<p class="p3"><span class="s2">x = {<span class="Apple-converted-space"> </span></span></p>
<p class="p16"><span class="s3"><span class="Apple-tab-span">	</span></span><span class="s2">ZeroXBufRd</span><span class="s3">.ar(</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>b, z,<span class="Apple-converted-space"> </span></span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>zeroX: </span><span class="s7">LFDNoise3</span><span class="s2">.ar(</span><span class="s7">SinOsc</span><span class="s2">.ar(0.1).range(1, 10)).range(1, 15),</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>rate: </span><span class="s7">Dstutter</span><span class="s2">(</span><span class="s7">Dstutter</span><span class="s2">(3, </span><span class="s7">Dwhite</span><span class="s2">(1, 5)), </span><span class="s7">Dseq</span><span class="s2">([0.5, 1, 1.5], </span><span class="s9">inf</span><span class="s2">)),</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>rateMul: </span><span class="s7">LFDNoise3</span><span class="s2">.ar(5).range(1, 5)</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span>) ! 2</span></p>
<p class="p3"><span class="s2">}.play</span></p>
<p class="p3"><span class="s2">)</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// free resources</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">(</span></p>
<p class="p3"><span class="s2">b.free;</span></p>
<p class="p3"><span class="s2">z.free;</span></p>
<p class="p3"><span class="s2">)</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p13"><span class="s2"><b>Ex.4) Multichannel usage and the 'bufMix' arg</b></span></p>
<p class="p13"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// Without passing a bufMix arg the size of the returned signal is determined by the buffer input.<span class="Apple-converted-space"> </span></span></p>
<p class="p15"><span class="s2">// It may be a single channel buffer or an array of single channel buffers,<span class="Apple-converted-space"> </span></span></p>
<p class="p15"><span class="s2">// in correspondence with the analysis buffer(s) - multichannel buffers are not allowed.<span class="Apple-converted-space"> </span></span></p>
<p class="p15"><span class="s2">// If bufMix is passed, it determines the size of the returned signal,<span class="Apple-converted-space"> </span></span></p>
<p class="p15"><span class="s2">// its components can be demand rate or other ugens to control switching between buffers per half waveset.</span></p>
<p class="p15"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// Note: buffer switching can become CPU-demanding with a lot of Buffers<span class="Apple-converted-space"> </span></span></p>
<p class="p15"><span class="s2">// as for fast switching it is necessary to play all in parallel</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">(</span></p>
<p class="p15"><span class="s2">// boot with extended resources</span></p>
<p class="p3"><span class="s2">s = </span><span class="s7">Server</span><span class="s2">.local;</span></p>
<p class="p3"><span class="s7">Server</span><span class="s2">.default = s;</span></p>
<p class="p3"><span class="s2">s.options.numWireBufs = 256;<span class="Apple-converted-space"> </span></span></p>
<p class="p3"><span class="s2">s.options.memSize = 8192 * 32;<span class="Apple-converted-space"> </span></span></p>
<p class="p3"><span class="s2">s.reboot;</span></p>
<p class="p3"><span class="s2">)</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// prepare 3 buffers</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">(</span></p>
<p class="p3"><span class="s2">b = { </span><span class="s7">Buffer</span><span class="s2">.alloc(s, 1000, 1) } ! 3;</span></p>
<p class="p3"><span class="s2">z = { </span><span class="s7">Buffer</span><span class="s2">.alloc(s, 100, 1) } ! 3;</span></p>
<p class="p3"><span class="s2">)</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// fill with basic waveforms</span></p>
<p class="p3"><span class="s2">(</span></p>
<p class="p3"><span class="s2">{</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s8">var</span><span class="s2"> src = [</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s7">SinOsc</span><span class="s2">.ar(400),</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s7">LFTri</span><span class="s2">.ar(400),</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s7">SinOsc</span><span class="s2">.ar(400) ** 10</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span>];</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s7">ZeroXBufWr</span><span class="s2">.ar(src, b, z, startWithZeroX: 1, doneAction: 2);</span></p>
<p class="p16"><span class="s3"><span class="Apple-tab-span">	</span></span><span class="s2">Silent</span><span class="s3">.ar</span></p>
<p class="p3"><span class="s2">}.play</span></p>
<p class="p3"><span class="s2">)</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">s.scope(3)</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// play 3 channels</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z, zeroX: 1) * 0.1 }.play</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// play from 1st buffer</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z, bufMix: 0, zeroX: </span><span class="s7">Dseq</span><span class="s2">([0, 1], </span><span class="s9">inf</span><span class="s2">)) * 0.2 }.play</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// play from 3rd and 1st buffer</span></p>
<p class="p15"><span class="s2">// to use equally defined demand rate ugens for both, wrap them into a Function</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z, bufMix: [2, 0], zeroX: { </span><span class="s7">Dseq</span><span class="s2">([0, 1], </span><span class="s9">inf</span><span class="s2">) }) * 0.1 }.play</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// play 2 channels with different zeroX sequences</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">(</span></p>
<p class="p3"><span class="s2">x = {</span></p>
<p class="p16"><span class="s3"><span class="Apple-tab-span">	</span></span><span class="s2">ZeroXBufRd</span><span class="s3">.ar(</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>b, z,</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>bufMix: [1, 2],</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>zeroX: [</span><span class="s7">Dseq</span><span class="s2">([0, 0, 1], </span><span class="s9">inf</span><span class="s2">), </span><span class="s7">Dseq</span><span class="s2">([0, 1], </span><span class="s9">inf</span><span class="s2">)]</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span>) * 0.1</span></p>
<p class="p3"><span class="s2">}.play</span></p>
<p class="p3"><span class="s2">)</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// buffers can be switched per half waveset</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z, bufMix: </span><span class="s7">Dseq</span><span class="s2">([0, 1, 2], </span><span class="s9">inf</span><span class="s2">), zeroX: 2, mul: 0.3) }.play</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z, bufMix: </span><span class="s7">Dseq</span><span class="s2">([0, 1], </span><span class="s9">inf</span><span class="s2">), zeroX: </span><span class="s7">Dseq</span><span class="s2">([1, 2], </span><span class="s9">inf</span><span class="s2">), mul: 0.3) }.play</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// Gendy-like texture</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">(</span></p>
<p class="p3"><span class="s2">x = {</span></p>
<p class="p16"><span class="s3"><span class="Apple-tab-span">	</span></span><span class="s2">ZeroXBufRd</span><span class="s3">.ar(</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>b, z,</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>bufMix: { </span><span class="s7">Dseq</span><span class="s2">([0, 1, 2], </span><span class="s9">inf</span><span class="s2">) } ! 2,</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>zeroX: 2,</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>mul: 0.1,</span></p>
<p class="p15"><span class="s3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s2">// array of Drands with different offset</span></p>
<p class="p15"><span class="s3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s2">// the average of the Drand output is 50,</span></p>
<p class="p15"><span class="s3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s2">// so on average 1/4 is added to x</span></p>
<p class="p15"><span class="s3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s2">// and the harmonic relation of L:R is 5:7 -&gt; tritone</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>rate: [1, 1.5].collect { </span><span class="s8">|x|</span><span class="s2"> </span><span class="s7">Drand</span><span class="s2">((1..100) / 200 + x, </span><span class="s9">inf</span><span class="s2">) }</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span>)</span></p>
<p class="p3"><span class="s2">}.play</span></p>
<p class="p3"><span class="s2">)</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// bufMix determines size</span></p>
<p class="p15"><span class="s2">// other args are expanded accordingly</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">(</span></p>
<p class="p3"><span class="s2">x = {</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z,</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>bufMix: { </span><span class="s7">Dseq</span><span class="s2">([0, 1, 2], </span><span class="s9">inf</span><span class="s2">) } ! 2,</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>zeroX: { </span><span class="s7">Dseq</span><span class="s2">([1, 2], </span><span class="s9">inf</span><span class="s2">) },</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>mul: { </span><span class="s7">Dstutter</span><span class="s2">(</span><span class="s7">Diwhite</span><span class="s2">(1, 1000), </span><span class="s7">Drand</span><span class="s2">([0.01, 0.07, 0.2], </span><span class="s9">inf</span><span class="s2">)) },</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>rate: { </span><span class="s7">Dstutter</span><span class="s2">(</span><span class="s7">Diwhite</span><span class="s2">(1, 12), </span><span class="s7">Dwhite</span><span class="s2">(0.1, 10)) }</span></p>
<p class="p3"><span class="s2"><span class="Apple-tab-span">	</span>)</span></p>
<p class="p3"><span class="s2">}.play</span></p>
<p class="p3"><span class="s2">)</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">x.release</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p7"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p13"><span class="s2"><b>Ex.5) The overall envelope</b></span></p>
<p class="p13"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// The finishing of a ZeroXBufRd is not detemined by finite demand rate ugens but by an overall envelope,<span class="Apple-converted-space"> </span></span></p>
<p class="p15"><span class="s2">// its release section is triggered by a maximum number of half wavesets ('length') or a maximum time.<span class="Apple-converted-space"> </span></span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// Buffers from Ex.4</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">{ </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b[0], z[0], rate: 1, length: 10, rel: 0.01) }.plot(0.03)</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">{ </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b[0], z[0], rate: 1, maxTime: 0.01, rel: 0.01) }.plot(0.03)</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// envelopes can be differentiated</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">{ </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b[0..1], z[0..1], rate: 1, maxTime: [0.01, 0.005], rel: [0.005, 0.02]) }.plot(0.03)</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">{ </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b[0..1], z[0..1], rate: 1, length: [7, 2], rel: [0.005, 0.02]) }.plot(0.03)</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p15"><span class="s2">// there should be only one doneAction 2 in this case</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">{ </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b[0..1], z[0..1], rate: 1, maxTime: [0.01, 0.005], rel: [0.05, 0.5], doneAction: [0, 2]) }.play</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2">(</span></p>
<p class="p3"><span class="s2">b.do(</span><span class="s7">_</span><span class="s2">.free);</span></p>
<p class="p3"><span class="s2">z.do(</span><span class="s7">_</span><span class="s2">.free);</span></p>
<p class="p3"><span class="s2">)</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p3"><span class="s2"><br>
</span></p>
<p class="p13"><span class="s2"><b>Ex.6) Simultaneous writing and reading</b></span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// The reading of half wavesets can start before analysis is finished,</span></p>
<p class="p18"><span class="s2">// if ZeroXBufRd is carefully used in with</span><span class="s3"> </span><span class="s2">a bit of delay.</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// prepare buffers</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">(</span></p>
<p class="p8"><span class="s2">p = </span><span class="s7">Platform</span><span class="s2">.resourceDir +/+ </span><span class="s10">"sounds/a11wlk01.wav"</span><span class="s2">;</span></p>
<p class="p8"><span class="s2">b = </span><span class="s7">Buffer</span><span class="s2">.read(s, p);</span></p>
<p class="p8"><span class="s2">)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">(</span></p>
<p class="p8"><span class="s2">z = </span><span class="s7">Buffer</span><span class="s2">.alloc(s, b.duration * 44100 / 5, 1);</span></p>
<p class="p8"><span class="s2">s.scope;</span></p>
<p class="p8"><span class="s2">)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// Here the average playback rate equals 1 (0.8 = 4/5, 1.25 = 5/4),</span></p>
<p class="p18"><span class="s2">// so playback will not be faster than writing.</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">(</span></p>
<p class="p8"><span class="s2">{</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s8">var</span><span class="s2"> src = </span><span class="s7">PlayBuf</span><span class="s2">.ar(1, b, </span><span class="s7">BufRateScale</span><span class="s2">.ir(b));</span></p>
<p class="p18"><span class="s3"><span class="Apple-tab-span">	</span></span><span class="s2">// write zero crossings, but no need to overwrite sound buffer</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s7">ZeroXBufWr</span><span class="s2">.ar(src, b, z, startWithZeroX: 1, writeSndBuf: </span><span class="s9">false</span><span class="s2">);</span></p>
<p class="p19"><span class="s3"><span class="Apple-tab-span">	</span></span><span class="s2">DelayL</span><span class="s3">.ar(</span></p>
<p class="p19"><span class="s3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s2">ZeroXBufRd</span><span class="s3">.ar(</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>b, z,</span></p>
<p class="p18"><span class="s3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s2">// Dseries keeps counting through the half-filled zeroX buffer</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>zeroX: </span><span class="s7">Dseries</span><span class="s2">(),</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>rate: </span><span class="s7">Dstutter</span><span class="s2">(10, </span><span class="s7">Dseq</span><span class="s2">([0.8, 1, 1.25], </span><span class="s9">inf</span><span class="s2">)),</span></p>
<p class="p18"><span class="s3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s2">// estimate end time</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>maxTime: b.duration + 1,</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>doneAction: 2</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>),</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>0.2,</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>0.1</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span>) ! 2;</span></p>
<p class="p8"><span class="s2">}.play</span></p>
<p class="p8"><span class="s2">)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">(</span></p>
<p class="p8"><span class="s2">b.free;</span></p>
<p class="p8"><span class="s2">z.free;</span></p>
<p class="p8"><span class="s2">)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// The same can be done with a live-generated signal or a mic input,</span></p>
<p class="p18"><span class="s2">// but ensure that reading comes after writing !</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// FAILURE BY BAD DEFINITION !</span></p>
<p class="p18"><span class="s2">// rates are fast, so zeroX indices are referred before analysis<span class="Apple-converted-space"> </span></span></p>
<p class="p18"><span class="s2">// resulting in garbage noise</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">(</span></p>
<p class="p8"><span class="s2">b = { </span><span class="s7">Buffer</span><span class="s2">.alloc(s, 5 * 44100) } ! 2;</span></p>
<p class="p8"><span class="s2">z = { </span><span class="s7">Buffer</span><span class="s2">.alloc(s, 2 * 44100) } ! 2;</span></p>
<p class="p8"><span class="s2">)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">(</span></p>
<p class="p8"><span class="s2">{</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s8">var</span><span class="s2"> src = </span><span class="s7">LFDNoise3</span><span class="s2">.ar(300 ! 2), sig;</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s7">ZeroXBufWr</span><span class="s2">.ar(src, b, z, startWithZeroX: 1);</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span>sig = </span><span class="s7">DelayL</span><span class="s2">.ar(</span></p>
<p class="p19"><span class="s3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s2">ZeroXBufRd</span><span class="s3">.ar(</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>b, z,</span></p>
<p class="p18"><span class="s3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s2">// Dseries keeps counting through the half-filled zeroX buffer</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>zeroX: { </span><span class="s7">Dseries</span><span class="s2">() },</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>rate: { </span><span class="s7">Dseq</span><span class="s2">((1..10) / </span><span class="s7">LFDNoise3</span><span class="s2">.ar(3).range(5, 10) + 1, </span><span class="s9">inf</span><span class="s2">) },</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>mul: { </span><span class="s7">Dstutter</span><span class="s2">(</span><span class="s7">Dwhite</span><span class="s2">(50, 500), </span><span class="s7">Drand</span><span class="s2">([0.02, 0.1, 0.5], </span><span class="s9">inf</span><span class="s2">)) },</span></p>
<p class="p18"><span class="s3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s2">// estimate end time</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>maxTime: 10,</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>att: 0.2,</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>rel: 5,</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>doneAction: 2</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>),</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>0.2,</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>0.1</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span>);</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s7">LeakDC</span><span class="s2">.ar(sig)</span></p>
<p class="p8"><span class="s2">}.play</span></p>
<p class="p8"><span class="s2">)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">//<span class="Apple-converted-space">  </span>Reasonable realtime usage</span></p>
<p class="p18"><span class="s2">//<span class="Apple-converted-space">  </span>zeroX is deferred by stuttering, rates are sufficiently low</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">(</span></p>
<p class="p8"><span class="s2">b.do(</span><span class="s7">_</span><span class="s2">.zero);</span></p>
<p class="p8"><span class="s2">z.do(</span><span class="s7">_</span><span class="s2">.zero);</span></p>
<p class="p8"><span class="s2">)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">(</span></p>
<p class="p8"><span class="s2">{</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s8">var</span><span class="s2"> src = </span><span class="s7">LFDNoise3</span><span class="s2">.ar(3000 ! 2);</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s7">ZeroXBufWr</span><span class="s2">.ar(src, b, z, startWithZeroX: 1);</span></p>
<p class="p19"><span class="s3"><span class="Apple-tab-span">	</span></span><span class="s2">DelayL</span><span class="s3">.ar(</span></p>
<p class="p19"><span class="s3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s2">ZeroXBufRd</span><span class="s3">.ar(<span class="Apple-tab-span">	</span></span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>b, z,</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>zeroX: { </span><span class="s7">Dstutter</span><span class="s2">(</span><span class="s7">Dwhite</span><span class="s2">(50, 300), </span><span class="s7">Dseries</span><span class="s2">()) * 2 + </span><span class="s7">Dseq</span><span class="s2">((1..4), </span><span class="s9">inf</span><span class="s2">) },</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>rate: { </span><span class="s7">Dseq</span><span class="s2">((1..5) / </span><span class="s7">LFDNoise3</span><span class="s2">.ar(3).range(5, 10) + 0.5, </span><span class="s9">inf</span><span class="s2">) },</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>mul: { </span><span class="s7">Dstutter</span><span class="s2">(</span><span class="s7">Dwhite</span><span class="s2">(50, 500), </span><span class="s7">Drand</span><span class="s2">([0.05, 0.3, 0.7], </span><span class="s9">inf</span><span class="s2">)) },</span></p>
<p class="p18"><span class="s3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s2">// estimate end time</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>maxTime: 20,</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>att: 0.2,</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>rel: 5,</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>doneAction: 2</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>),</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>0.2,</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>0.1</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span>);</span></p>
<p class="p8"><span class="s2">}.play</span></p>
<p class="p8"><span class="s2">)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">(</span></p>
<p class="p8"><span class="s2">b.do(</span><span class="s7">_</span><span class="s2">.free);</span></p>
<p class="p8"><span class="s2">z.do(</span><span class="s7">_</span><span class="s2">.free);</span></p>
<p class="p8"><span class="s2">)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// It's of course unproblematic – and still quasi realtime – to fully a analyse<span class="Apple-converted-space"> </span></span></p>
<p class="p18"><span class="s2">// a snippet of sound with ZeroXBufWr before freely using ZeroXBufRd in the same synth</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p13"><span class="s2"><b>Ex.7) Adjusting zero crossings</b></span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// In general a half waveset isn't totally unipolar:</span></p>
<p class="p18"><span class="s2">// Zero crossing indices indicate the change of the sign of a signal,</span></p>
<p class="p18"><span class="s2">// so with this convention the last sample of the half waveset itself</span></p>
<p class="p18"><span class="s2">// has a different sign.</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// This can have the consequence that, depending on the playback rate,</span></p>
<p class="p18"><span class="s2">// sawtooth-like effects might occur. Such artefacts can be circumvented by</span></p>
<p class="p18"><span class="s2">// adjusting buffer values at zero crossing indices to 0,</span></p>
<p class="p18"><span class="s2">// so playback of (half) wavesets is smoothened, especially with extreme rate values.</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">(</span></p>
<p class="p8"><span class="s2">p = </span><span class="s7">Platform</span><span class="s2">.resourceDir +/+ </span><span class="s10">"sounds/a11wlk01.wav"</span><span class="s2">;</span></p>
<p class="p8"><span class="s2">b = </span><span class="s7">Buffer</span><span class="s2">.read(s, p);</span></p>
<p class="p8"><span class="s2">z = </span><span class="s7">Buffer</span><span class="s2">.alloc(s, 100000);</span></p>
<p class="p8"><span class="s2">)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// analyse buffer</span></p>
<p class="p8"><span class="s2">(</span></p>
<p class="p8"><span class="s2">{</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s8">var</span><span class="s2"> src = </span><span class="s7">PlayBuf</span><span class="s2">.ar(1, b, </span><span class="s7">BufRateScale</span><span class="s2">.ir(b), doneAction: 2);</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s7">ZeroXBufWr</span><span class="s2">.ar(src, b, z, startWithZeroX: 0, doneAction: 2);</span></p>
<p class="p8"><span class="s2">}.play</span></p>
<p class="p8"><span class="s2">)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// this half waveset clearly shows the effect</span></p>
<p class="p18"><span class="s2">// (tested with samplerate 44100)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">s.scope</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">x = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z, </span><span class="s9">nil</span><span class="s2">, 220, rate: 0.1) * 2 }.play</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// adjust zeros, also works with arrays of Buffers</span></p>
<p class="p18"><span class="s2">// you can apply it while running, it might take a moment though</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">b.adjustZeroXs(z)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">x.release</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// alternatively adjusting zero crossings can be chosen as option with analysis:</span></p>
<p class="p18"><span class="s2">// set flag 'adjustZeroXs' to 1</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">(</span></p>
<p class="p8"><span class="s2">p = </span><span class="s7">Platform</span><span class="s2">.resourceDir +/+ </span><span class="s10">"sounds/a11wlk01.wav"</span><span class="s2">;</span></p>
<p class="p8"><span class="s2">b = </span><span class="s7">Buffer</span><span class="s2">.read(s, p);</span></p>
<p class="p8"><span class="s2">z = </span><span class="s7">Buffer</span><span class="s2">.alloc(s, 100000);</span></p>
<p class="p8"><span class="s2">)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// analyse buffer</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">(</span></p>
<p class="p8"><span class="s2">{</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s8">var</span><span class="s2"> src = </span><span class="s7">PlayBuf</span><span class="s2">.ar(1, b, </span><span class="s7">BufRateScale</span><span class="s2">.ir(b), doneAction: 2);</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s7">ZeroXBufWr</span><span class="s2">.ar(src, b, z, startWithZeroX: 0, adjustZeroXs: 1, doneAction: 2);</span></p>
<p class="p8"><span class="s2">}.play</span></p>
<p class="p8"><span class="s2">)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">s.scope</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">x = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z, </span><span class="s9">nil</span><span class="s2">, 220, rate: 0.1) * 2 }.play</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">x.release</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// the flag 'adjustZeroXs' can also be set to 2</span></p>
<p class="p18"><span class="s2">// in this case zero crossings have a minimum distance of 2 samples</span></p>
<p class="p18"><span class="s2">// This goes along with ZeroXBufRd's convention to play one half waveset with a minimum length of 2 samples</span></p>
<p class="p18"><span class="s2">// (otherwise it couldn't act as a trigger)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// the difference can be observed with fast switches between signs like with WhiteNoise</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">(</span></p>
<p class="p8"><span class="s2">b = </span><span class="s7">Buffer</span><span class="s2">.alloc(s, 2000);</span></p>
<p class="p8"><span class="s2">z = </span><span class="s7">Buffer</span><span class="s2">.alloc(s, 2000);</span></p>
<p class="p8"><span class="s2">)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">(</span></p>
<p class="p8"><span class="s2">{</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s8">var</span><span class="s2"> src = </span><span class="s7">WhiteNoise</span><span class="s2">.ar();</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s7">ZeroXBufWr</span><span class="s2">.ar(src, b, z, startWithZeroX: 0, adjustZeroXs: 1, doneAction: 2) * 0.2;</span></p>
<p class="p8"><span class="s2">}.play</span></p>
<p class="p8"><span class="s2">)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">s.scope</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// this generates a more pulsar-like waveform with adjacent zero crossings,</span></p>
<p class="p18"><span class="s2">// note that transitions to flat sections are smoothened by cubic interpolation</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">x = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z, </span><span class="s9">nil</span><span class="s2">, </span><span class="s7">Dseq</span><span class="s2">((0..50), </span><span class="s9">inf</span><span class="s2">), rate: 0.03) * 0.5 }.play</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">x.release</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// there are no flat sections with 'adjustZeroXs' set to 2</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">(</span></p>
<p class="p8"><span class="s2">b.zero;</span></p>
<p class="p8"><span class="s2">z.zero;</span></p>
<p class="p8"><span class="s2">)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">(</span></p>
<p class="p8"><span class="s2">{</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s8">var</span><span class="s2"> src = </span><span class="s7">WhiteNoise</span><span class="s2">.ar();</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s7">ZeroXBufWr</span><span class="s2">.ar(src, b, z, startWithZeroX: 0, adjustZeroXs: 2, doneAction: 2) * 0.2;</span></p>
<p class="p8"><span class="s2">}.play</span></p>
<p class="p8"><span class="s2">)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">x = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(b, z, </span><span class="s9">nil</span><span class="s2">, </span><span class="s7">Dseq</span><span class="s2">((0..50), </span><span class="s9">inf</span><span class="s2">), rate: 0.03) * 0.5 }.play</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">x.release</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p13"><span class="s2"><b>Ex.8) Granulation with movement through a buffer</b></span></p>
<p class="p13"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// See Buffer Granulation tutorial, Ex. 1g</span></p>
<p class="p13"><span class="s2"><br>
</span></p>
<p class="p13"><span class="s2"><b>Ex.9) Smooth concatenation of adjacent wavesets</b></span></p>
<p class="p13"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// If we invert the waveset with every change of direction we smoothly continue its slope at the zero crossing.</span></p>
<p class="p18"><span class="s2">// This can be done simply by using the sequence of directions as a ZeroXBufRd's multiplier input,</span></p>
<p class="p18"><span class="s2">// the waveform then consists of antisymmetric segments.</span></p>
<p class="p20"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// Dwalk is suited for this usage, but should not get ordinary ugens as input</span></p>
<p class="p18"><span class="s2">// for stepsPerDir and stepWidth</span></p>
<p class="p20"><span class="s2"><br>
</span></p>
<p class="p20"><span class="s2">(</span></p>
<p class="p18"><span class="s2">// boot with extended resources</span></p>
<p class="p20"><span class="s2"><br>
</span></p>
<p class="p20"><span class="s2">s = </span><span class="s11">Server</span><span class="s2">.local;</span></p>
<p class="p20"><span class="s11">Server</span><span class="s2">.default = s;</span></p>
<p class="p20"><span class="s2">s.options.memSize = 8192 * 32;</span></p>
<p class="p20"><span class="s2">s.reboot;</span></p>
<p class="p20"><span class="s2">s.scope;</span></p>
<p class="p20"><span class="s2">s.freqscope;</span></p>
<p class="p20"><span class="s2">)</span></p>
<p class="p20"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// load soundfile into buffer</span></p>
<p class="p18"><span class="s2">// allocate buffer for zero crossings</span></p>
<p class="p20"><span class="s2"><br>
</span></p>
<p class="p20"><span class="s2">(</span></p>
<p class="p20"><span class="s2">p = </span><span class="s11">Platform</span><span class="s2">.resourceDir +/+ </span><span class="s12">"sounds/a11wlk01.wav"</span><span class="s2">;</span></p>
<p class="p20"><span class="s2">b = </span><span class="s11">Buffer</span><span class="s2">.read(s, p);</span></p>
<p class="p20"><span class="s2">z = </span><span class="s11">Buffer</span><span class="s2">.alloc(s, 100000);</span></p>
<p class="p20"><span class="s2">)</span></p>
<p class="p20"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// analyse buffer</span></p>
<p class="p20"><span class="s2"><br>
</span></p>
<p class="p20"><span class="s2">(</span></p>
<p class="p20"><span class="s2">{</span></p>
<p class="p20"><span class="s2"><span class="Apple-converted-space">    </span></span><span class="s13">var</span><span class="s2"> src = </span><span class="s11">PlayBuf</span><span class="s2">.ar(1, b, </span><span class="s11">BufRateScale</span><span class="s2">.ir(b), doneAction: 2);</span></p>
<p class="p20"><span class="s2"><span class="Apple-converted-space">    </span></span><span class="s11">ZeroXBufWr</span><span class="s2">.ar(src, b, z, startWithZeroX: 0, doneAction: 2);</span></p>
<p class="p20"><span class="s2">}.play</span></p>
<p class="p20"><span class="s2">)</span></p>
<p class="p20"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// check the number of zero crossings</span></p>
<p class="p20"><span class="s2"><br>
</span></p>
<p class="p20"><span class="s2">(</span></p>
<p class="p20"><span class="s2">z.loadToFloatArray(</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span>action: { </span><span class="s13">|x|</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s14">~zeroXs</span><span class="s2"> = x.reject(</span><span class="s11">_</span><span class="s2">==0);</span></p>
<p class="p21"><span class="s15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s2">~zeroNum</span><span class="s15"> = </span><span class="s2">~zeroXs</span><span class="s15">.size;</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s12">"done"</span><span class="s2">.postln;</span></p>
<p class="p22"><span class="s15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s2">"number of zero crossings: "</span><span class="s15">.post;</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s14">~zeroNum</span><span class="s2">.postln</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span>}</span></p>
<p class="p20"><span class="s2">)</span></p>
<p class="p20"><span class="s2">)</span></p>
<p class="p20"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// mix short and long walks into one direction</span></p>
<p class="p20"><span class="s2"><br>
</span></p>
<p class="p20"><span class="s2">(</span></p>
<p class="p20"><span class="s2">x = {</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s13">var</span><span class="s2"> sig, zeroX, dir;</span></p>
<p class="p20"><span class="s2"><br>
</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span>#zeroX, dir = </span><span class="s11">Dwalk</span><span class="s2">(</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s11">Dwrand</span><span class="s2">([1, 3, 50], [50, 10, 1].normalizeSum, </span><span class="s16">inf</span><span class="s2">),</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>start: 1000,</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>lo: 100,</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>hi: 5000,</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>withDirs: 1</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span>);</span></p>
<p class="p18"><span class="s15"><span class="Apple-tab-span">	</span></span><span class="s2">// we need dir twice</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span>dir = </span><span class="s11">Dunique</span><span class="s2">(dir, 2048 ** 2);</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span>sig = </span><span class="s11">ZeroXBufRd</span><span class="s2">.ar(</span></p>
<p class="p20"><span class="s2"><span class="Apple-converted-space">        </span>b, z,</span></p>
<p class="p20"><span class="s2"><span class="Apple-converted-space">        </span></span><span class="s16">nil</span><span class="s2">,</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>zeroX,</span></p>
<p class="p18"><span class="s15"><span class="Apple-converted-space">        </span>mul: dir, </span><span class="s2">// change sign together with direction -&gt; smooth continuation of slope</span></p>
<p class="p20"><span class="s2"><span class="Apple-converted-space">        </span>rate: 1,</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>dir: dir</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span>);</span></p>
<p class="p18"><span class="s15"><span class="Apple-tab-span">	</span></span><span class="s2">// stereo by simple delay</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s11">DelayL</span><span class="s2">.ar(sig, 0.2, [0, 0.1])</span></p>
<p class="p20"><span class="s2">}.play</span></p>
<p class="p20"><span class="s2">)</span></p>
<p class="p20"><span class="s2"><br>
</span></p>
<p class="p20"><span class="s2">x.release</span></p>
<p class="p20"><span class="s2"><br>
</span></p>
<p class="p20"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// decorrelation by using different rate sequences,</span></p>
<p class="p18"><span class="s2">// as zeroX is used twice it also needs to be dunique-fied.</span></p>
<p class="p20"><span class="s2"><br>
</span></p>
<p class="p20"><span class="s2">(</span></p>
<p class="p20"><span class="s2">x = {</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s13">var</span><span class="s2"> sig, zeroX, dir;</span></p>
<p class="p20"><span class="s2"><br>
</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span>#zeroX, dir = </span><span class="s11">Dwalk</span><span class="s2">(</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s11">Dwrand</span><span class="s2">([1, 5, 50], [50, 5, 1].normalizeSum, </span><span class="s16">inf</span><span class="s2">),</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>start: 1000,</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>lo: 100,</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>hi: 5000,</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>withDirs: 1</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span>);</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span>dir = </span><span class="s11">Dunique</span><span class="s2">(dir, 2048 ** 2);</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span>zeroX = </span><span class="s11">Dunique</span><span class="s2">(zeroX, 2048 ** 2);</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span>{</span></p>
<p class="p23"><span class="s15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s2">ZeroXBufRd</span><span class="s15">.ar(</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>b, z,</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s16">nil</span><span class="s2">,</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>zeroX,</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>mul: dir,</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>rate: </span><span class="s11">Dstutter</span><span class="s2">(</span><span class="s11">Dwhite</span><span class="s2">(1, 20), </span><span class="s11">Dwhite</span><span class="s2">(0.6, 1.4)),</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>dir: dir</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>)</span></p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span>} ! 2</span></p>
<p class="p20"><span class="s2">}.play</span></p>
<p class="p20"><span class="s2">)</span></p>
<p class="p20"><span class="s2"><br>
</span></p>
<p class="p20"><span class="s2">x.release</span><span class="s17"><br>
</span></p>
<p class="p13"><span class="s2"><br>
</span></p>
<p class="p13"><span class="s2"><b>Ex.10) Smooth concatenation of adjacent segments restricted by turning points resp. local minima or maxima</b></span></p>
<p class="p13"><span class="s2"><br>
</span></p>
<p class="p13"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// This is similar to the previous approach, but here we can change direction</span></p>
<p class="p18"><span class="s2">// where the slope is zero, so we need an analysis of the slope's zero crossings,</span></p>
<p class="p18"><span class="s2">// the waveform consists of symmetric segments.</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// Dwalk is suited for this usage, but should not get ordinary ugens as input</span></p>
<p class="p18"><span class="s2">// for stepsPerDir and stepWidth</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">(</span></p>
<p class="p18"><span class="s2">// boot with extended resources</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">s = </span><span class="s7">Server</span><span class="s2">.local;</span></p>
<p class="p8"><span class="s7">Server</span><span class="s2">.default = s;</span></p>
<p class="p8"><span class="s2">s.options.memSize = 8192 * 32;</span></p>
<p class="p8"><span class="s2">s.reboot;</span></p>
<p class="p8"><span class="s2">s.scope;</span></p>
<p class="p8"><span class="s2">s.freqscope;</span></p>
<p class="p8"><span class="s2">)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// load soundfile into buffer</span></p>
<p class="p18"><span class="s2">// allocate buffer for zero crossings (of slope !)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">(</span></p>
<p class="p8"><span class="s2">p = </span><span class="s7">Platform</span><span class="s2">.resourceDir +/+ </span><span class="s10">"sounds/a11wlk01.wav"</span><span class="s2">;</span></p>
<p class="p8"><span class="s2">b = </span><span class="s7">Buffer</span><span class="s2">.read(s, p);</span></p>
<p class="p18"><span class="s3">c = </span><span class="s7">Buffer</span><span class="s3">.read(s, p); </span><span class="s2">// not absolutely needed, just in case to record slope</span></p>
<p class="p8"><span class="s2">z = </span><span class="s7">Buffer</span><span class="s2">.alloc(s, 100000);</span></p>
<p class="p8"><span class="s2">)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// analyse slope, indices of turning points resp. local minima or maxima are written to z</span></p>
<p class="p18"><span class="s2">// buffer c isn't overwritten here (adjustZeroXs == -1)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">(</span></p>
<p class="p8"><span class="s2">{</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s8">var</span><span class="s2"> slope = </span><span class="s7">Slope</span><span class="s2">.ar(</span><span class="s7">PlayBuf</span><span class="s2">.ar(1, b, </span><span class="s7">BufRateScale</span><span class="s2">.ir(b), doneAction: 2));</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s8">var</span><span class="s2"> env = </span><span class="s7">EnvGen</span><span class="s2">.ar(</span><span class="s7">Env</span><span class="s2">([0, 1, 1, 0], [0.01, b.duration - 0.02, 0.01]));</span></p>
<p class="p8"><span class="s2"><span class="Apple-converted-space">    </span></span><span class="s7">ZeroXBufWr</span><span class="s2">.ar(slope, c, z, adjustZeroXs: -1, doneAction: 2);</span></p>
<p class="p18"><span class="s3"><span class="Apple-tab-span">	</span></span><span class="s2">// slope is loud - don't want to play it !</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s7">Saw</span><span class="s2">.ar(100, 0.05) * env;</span></p>
<p class="p8"><span class="s2">}.play</span></p>
<p class="p8"><span class="s2">)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// slope has much more zero crossings than the original recording, check</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">(</span></p>
<p class="p8"><span class="s2">z.loadToFloatArray(</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span>action: { </span><span class="s8">|x|</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s18">~zeroXs</span><span class="s2"> = x.reject(</span><span class="s7">_</span><span class="s2">==0);</span></p>
<p class="p24"><span class="s3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s2">~zeroNum</span><span class="s3"> = </span><span class="s2">~zeroXs</span><span class="s3">.size;</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s10">"done"</span><span class="s2">.postln;</span></p>
<p class="p25"><span class="s3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s2">"number of positions where slope equals zero: "</span><span class="s3">.post;</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s18">~zeroNum</span><span class="s2">.postln</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span>}</span></p>
<p class="p8"><span class="s2">)</span></p>
<p class="p8"><span class="s2">)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// walk between turning points resp. local minima or maxima</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">(</span></p>
<p class="p8"><span class="s2">x = {</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s8">var</span><span class="s2"> sig, zeroX, dir;</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span>#zeroX, dir = </span><span class="s7">Dwalk</span><span class="s2">(</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s7">Dstutter</span><span class="s2">(</span><span class="s7">Dwhite</span><span class="s2">(1, 12), </span><span class="s7">Dwrand</span><span class="s2">([1, 3, 17], [10, 1, 1].normalizeSum, </span><span class="s9">inf</span><span class="s2">)),</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>start: 1000,</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>lo: 100,</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>hi: 25000,</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>withDirs: 1</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span>);</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span>sig = </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(</span></p>
<p class="p8"><span class="s2"><span class="Apple-converted-space">        </span>b, z,</span></p>
<p class="p8"><span class="s2"><span class="Apple-converted-space">        </span></span><span class="s9">nil</span><span class="s2">,</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>zeroX,</span></p>
<p class="p18"><span class="s3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>mul: 1,<span class="Apple-converted-space">  </span></span><span class="s2">// signal doesn't have to be inverted with direction changes</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>rate: 0.5,</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>dir: dir</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span>);</span></p>
<p class="p18"><span class="s3"><span class="Apple-tab-span">	</span></span><span class="s2">// stereo by simple delay</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s7">DelayL</span><span class="s2">.ar(</span><span class="s7">Limiter</span><span class="s2">.ar(sig * 10, 0.5), 0.2, [0, 0.1])</span></p>
<p class="p8"><span class="s2">}.play</span></p>
<p class="p8"><span class="s2">)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">x.release</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2">// stereo by decorrelated rate sequences</span></p>
<p class="p18"><span class="s2">// need to duniquefy dir and zeroX</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">(</span></p>
<p class="p8"><span class="s2">x = {</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s8">var</span><span class="s2"> sig, zeroX, dir;</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span>#zeroX, dir = </span><span class="s7">Dwalk</span><span class="s2">(</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s7">Dstutter</span><span class="s2">(</span><span class="s7">Dwhite</span><span class="s2">(1, 50), </span><span class="s7">Dwrand</span><span class="s2">([1, 3, 25], [10, 5, 1].normalizeSum, </span><span class="s9">inf</span><span class="s2">)),</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>start: 1000,</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>lo: 100,</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>hi: 25000,</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>withDirs: 1,</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>dUniqueBufSize: 2048 ** 2</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span>);</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span>dir = </span><span class="s7">Dunique</span><span class="s2">(dir, 2048 ** 2);</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span>zeroX = </span><span class="s7">Dunique</span><span class="s2">(zeroX, 2048 ** 2);</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span>sig = { </span><span class="s7">ZeroXBufRd</span><span class="s2">.ar(</span></p>
<p class="p8"><span class="s2"><span class="Apple-converted-space">        </span>b, z,</span></p>
<p class="p8"><span class="s2"><span class="Apple-converted-space">        </span></span><span class="s9">nil</span><span class="s2">,</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>zeroX,</span></p>
<p class="p18"><span class="s3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>mul: 1,<span class="Apple-converted-space">  </span></span><span class="s2">// signal doesn't have to be inverted with direction changes</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>rate: </span><span class="s7">Dstutter</span><span class="s2">(</span><span class="s7">Dwhite</span><span class="s2">(1, 2), </span><span class="s7">Dseq</span><span class="s2">((1..50) / 50 + 0.5, </span><span class="s9">inf</span><span class="s2">)),</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>dir: dir</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span>) } ! 2;</span></p>
<p class="p8"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s7">LeakDC</span><span class="s2">.ar(</span><span class="s7">Limiter</span><span class="s2">.ar(sig * 5, 0.3))</span></p>
<p class="p8"><span class="s2">}.play</span></p>
<p class="p8"><span class="s2">)</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2">x.release</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p8"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2"><br>
</span></p>
<p class="p18"><span class="s2"><br>
</span></p>
<p class="p13"><span class="s2"><br>
</span></p>
<p class="p13"><span class="s2"><br>
</span></p>
</body>
</html>
